<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Acidic Accident</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Acidic Accident">
<meta property="og:url" content="http://zxfred.github.io/page/2/index.html">
<meta property="og:site_name" content="Acidic Accident">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Acidic Accident">
  
    <link rel="alternate" href="/atom.xml" title="Acidic Accident" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Acidic Accident</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://zxfred.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-ES6使用模板字符串进行模板编译" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/27/ES6使用模板字符串进行模板编译/" class="article-date">
  <time datetime="2018-11-27T13:09:35.000Z" itemprop="datePublished">2018-11-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/27/ES6使用模板字符串进行模板编译/">ES6使用模板字符串进行模板编译</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文编辑自：阮一峰《ES6 标准入门》</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用模板字符串实现一个模板编译方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是模板</span></span><br><span class="line"><span class="keyword">let</span> template = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">  &lt;% for(let i=0; i &lt; data.supplies.length; i++) &#123; %&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;% &#125; %&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compile</span>(<span class="params">template</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 使用正则匹配, 把模板字符换成 echo() 包起来的 JavaScript 表达式字符串</span></span><br><span class="line">    <span class="keyword">const</span> evalExpr = <span class="regexp">/&lt;%=(.+?)%&gt;/g</span>;</span><br><span class="line">    <span class="keyword">const</span> expr = <span class="regexp">/&lt;%([\s\S]+?)%&gt;/g</span>;</span><br><span class="line"></span><br><span class="line">    template = template</span><br><span class="line">        .replace(evalExpr, <span class="string">'`); \n  echo( $1 ); \n  echo(`'</span>)</span><br><span class="line">        .replace(expr, <span class="string">'`); \n $1 \n  echo(`'</span>);</span><br><span class="line"></span><br><span class="line">    template = <span class="string">'echo(`'</span> + template + <span class="string">'`);'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把模板中的JS代码加入到另一段</span></span><br><span class="line">    <span class="keyword">let</span> script =</span><br><span class="line">    <span class="string">`(function parse(data)&#123;</span></span><br><span class="line"><span class="string">        let output = "";</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">        function echo(html)&#123;</span></span><br><span class="line"><span class="string">          output += html;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">        <span class="subst">$&#123; template &#125;</span></span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">        return output;</span></span><br><span class="line"><span class="string">    &#125;)`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> script;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 eval 让字符串变成可执行方法</span></span><br><span class="line"><span class="keyword">let</span> parse = <span class="built_in">eval</span>(compile(template))</span><br><span class="line"><span class="keyword">let</span> result = parse(&#123; <span class="attr">supplies</span>: [ <span class="string">"broom"</span>, <span class="string">"mop"</span>, <span class="string">"cleaner"</span> ] &#125;);</span><br><span class="line"><span class="comment">//   &lt;ul&gt;</span></span><br><span class="line"><span class="comment">//     &lt;li&gt;broom&lt;/li&gt;</span></span><br><span class="line"><span class="comment">//     &lt;li&gt;mop&lt;/li&gt;</span></span><br><span class="line"><span class="comment">//     &lt;li&gt;cleaner&lt;/li&gt;</span></span><br><span class="line"><span class="comment">//   &lt;/ul&gt;</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://zxfred.github.io/2018/11/27/ES6使用模板字符串进行模板编译/" data-id="cjqjg6fnq000aj8btat5gznt8" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ES6解构赋值的用途" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/23/ES6解构赋值的用途/" class="article-date">
  <time datetime="2018-11-23T09:54:12.000Z" itemprop="datePublished">2018-11-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/23/ES6解构赋值的用途/">ES6解构赋值的用途</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>转自：阮一峰 《ES6 入门》</p>
<p><strong>（1）交换变量的值</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure>
<p>上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p>
<p><strong>（2）从函数返回多个值</strong></p>
<p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure>
<p><strong>（3）函数参数的定义</strong></p>
<p>解构赋值可以方便地将一组参数与变量名对应起来。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>（4）提取JSON数据</strong></p>
<p>解构赋值对提取JSON对象中的数据，尤其有用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonData = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  status: <span class="string">"OK"</span>,</span><br><span class="line">  data: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(id, status, number);</span><br><span class="line"><span class="comment">// 42, "OK", [867, 5309]</span></span><br></pre></td></tr></table></figure>
<p>上面代码可以快速提取JSON数据的值。</p>
<p><strong>（5）函数参数的默认值</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  async = true,</span></span></span><br><span class="line"><span class="function"><span class="params">  beforeSend = function (</span>) </span>&#123;&#125;,</span><br><span class="line">  cache = <span class="literal">true</span>,</span><br><span class="line">  complete = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  crossDomain = <span class="literal">false</span>,</span><br><span class="line">  global = <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// ... more config</span></span><br><span class="line">&#125;) &#123;</span><br><span class="line">  <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。</p>
<p><strong>（6）遍历Map结构</strong></p>
<p>任何部署了Iterator接口的对象，都可以用for…of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure>
<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（7）输入模块的指定方法</strong></p>
<p>加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</span><br></pre></td></tr></table></figure>
<p>也可以很方便地将现有对象的方法，赋值到某个变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; log, sin, cos &#125; = <span class="built_in">Math</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码将<code>Math</code>对象的对数、正弦、余弦三个方法，赋值到对名称的变量上，使用起来就会方便很多。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zxfred.github.io/2018/11/23/ES6解构赋值的用途/" data-id="cjqjg6fno0008j8btutwmvww4" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-我的2018年度总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/21/我的2018年度总结/" class="article-date">
  <time datetime="2018-11-21T15:45:44.000Z" itemprop="datePublished">2018-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/21/我的2018年度总结/">我的2018年度总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>百度前端学院2018课程 CSS动画部分 + JS部分</p>
<p>Udacity 计算机科学导论 入门 Python</p>
<p>百度前端学院2017课程 基础部分</p>
<p>公司大大小小几十个项目</p>
<p>Ionic 3 向 4 的升级</p>
<p>找房子真的好累啊！Tired</p>
<p>搬家，收拾东西中。。。</p>
<p>今天终于把东西收拾差不多了</p>
<p>明天搬家+保洁+安宽带</p>
<p>今天是去新公司入职的第一天</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zxfred.github.io/2018/11/21/我的2018年度总结/" data-id="cjqjg6fom001lj8bttd4nzwzs" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript中的执行环境" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/19/JavaScript中的执行环境/" class="article-date">
  <time datetime="2018-11-19T13:04:40.000Z" itemprop="datePublished">2018-11-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/19/JavaScript中的执行环境/">JavaScript中的执行环境</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文转载自知乎：@柳兮</p>
<h2 id="什么是执行环境"><a href="#什么是执行环境" class="headerlink" title="什么是执行环境"></a><strong>什么是执行环境</strong></h2><p>JavaScript是一个单线程语言，意味着同一时间只能执行一个任务。当JavaScript解释器初始化执行代码时， 它首先默认进入全局执行环境（execution context），从此刻开始，函数的每次调用都会创建一个新的执行环境。</p>
<h2 id="执行环境的分类"><a href="#执行环境的分类" class="headerlink" title="执行环境的分类"></a><strong>执行环境的分类</strong></h2><ul>
<li>全局环境——JavaScript代码运行时首次进入的环境。</li>
<li>函数环境——当函数被调用时，会进入当前函数中执行代码。</li>
<li>Eval——eval内部的文本被执行时(因为eval不被鼓励使用，此处不做详细介绍)。</li>
</ul>
<h2 id="执行环境栈"><a href="#执行环境栈" class="headerlink" title="执行环境栈"></a><strong>执行环境栈</strong></h2><p>当JavaScript代码执行的时候，会进入不同的执行环境，这些执行环境会构成了一个执行环境栈（Execution context stack，ECS）。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。</p>
<p>代码在执行过程时遇到以上三种执行环境的代码时，都会生成一个对应的执行环境，压入执行环境栈中，当栈顶的上下文执行完毕之后，会自动出栈。下面用一个例子说明。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    fn2();</span><br><span class="line">&#125;</span><br><span class="line">fn1();</span><br></pre></td></tr></table></figure>
<p>第一步，全局执行环境入栈。</p>
<p>第二步，遇到fn1(),执行代码，创建自己的执行环境，入栈。</p>
<p>第三步，fn1的上下文入栈之后，接着执行其中的代码，遇到fn2()，创建自己的执行环境，入栈。</p>
<p>第四步，在fn2的执行环境中未创建新的执行环境，代码执行完毕之后,fn2的执行环境出栈。</p>
<p>第五步，fn2的执行环境出栈之后，继续执行fn1r的可执行代码，也未创建新的执行环境，出栈。这个时候栈中只剩下全局执行环境了。</p>
<p><strong>有5个需要记住的关键点，关于执行栈（调用栈）：</strong></p>
<ul>
<li>单线程。</li>
<li>同步执行。所有的执行环境都得等到栈顶的执行之后才能顺序执行</li>
<li>只有一个全局执行环境。</li>
<li>函数上下文是无限制的。</li>
<li>每次函数被调用时都会创建新的执行环境，包括调用自己。</li>
</ul>
<h2 id="深入了解执行环境"><a href="#深入了解执行环境" class="headerlink" title="深入了解执行环境"></a><strong>深入了解执行环境</strong></h2><h3 id="执行环境的构成"><a href="#执行环境的构成" class="headerlink" title="执行环境的构成"></a><strong>执行环境的构成</strong></h3><p>可以将每个执行环境抽象为一个对象并有三个属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">executionContextObj = &#123;</span><br><span class="line">    scopeChain: &#123; <span class="comment">/* 变量对象（variableObject）+ 所有父执行环境的变量对象*/</span> &#125;, </span><br><span class="line">    variableObject: &#123; <span class="comment">/*函数 arguments/参数，内部变量和函数声明 */</span> &#125;, </span><br><span class="line">    <span class="keyword">this</span>: &#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行环境的产生</p>
<p>在JavaScript解释器内部，每次调用执行环境，分为两个阶段：</p>
<p><strong>创建阶段(此时函数被调用，但未执行内部代码)：</strong></p>
<ul>
<li>设置[[Scope]]属性的值</li>
<li>设置变量对象VO，创建变量，函数和参数。</li>
<li>设置this的值。</li>
</ul>
<p><strong>激活/代码执行阶段：</strong></p>
<p>在当前上下文上运行/解释函数代码，并随着代码一行行执行指派变量的值和函数的引用。</p>
<h4 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a><strong>创建阶段</strong></h4><p>1.根据函数的参数，创建并初始化arguments object。</p>
<p>2.扫描上下文的函数声明：对于找到的函数声明，将函数名和函数引用存入VO中，如果VO中已经有同名函数，那么就进行覆盖。</p>
<p>3.扫面上下文的变量声明：对于找到的每个变量声明，将变量名存入VO中，并且将变量的值初始化为undefined。如果变量的名字已经在变量对象里存在，不会进行任何操作并继续扫描。</p>
<p><strong>要记住：函数扫描是在变量之前。</strong></p>
<p>让我们举一个栗子来说明：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'abby'</span>;</span><br><span class="line">    <span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<p>首先，当我调用person(20)的时候，创建的状态是这样:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fooExecutionContext = &#123;</span><br><span class="line">    scopeChain: &#123; ... &#125;,</span><br><span class="line">    variableObject: &#123;</span><br><span class="line">        <span class="built_in">arguments</span>: &#123;</span><br><span class="line">            <span class="number">0</span>: <span class="number">20</span>,</span><br><span class="line">            length: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        age: <span class="number">20</span>,</span><br><span class="line">        getAge: pointer to <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>),</span></span><br><span class="line"><span class="function">        <span class="title">name</span>: <span class="title">undefined</span>,</span></span><br><span class="line"><span class="function">        <span class="title">getName</span>: <span class="title">undefined</span>,</span></span><br><span class="line"><span class="function">    &#125;,</span></span><br><span class="line"><span class="function">    <span class="title">this</span>: </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>刚创建的时候，首先是指出函数的引用，然后按顺序对变量进行定义，初始化为undefined。当创建完成之后，执行流进入函数并且在上下文中运行/解释代码，指定函数的引用和变量的值，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fooExecutionContext = &#123;</span><br><span class="line">    scopeChain: &#123; ... &#125;,</span><br><span class="line">    variableObject: &#123;</span><br><span class="line">        <span class="built_in">arguments</span>: &#123;</span><br><span class="line">            <span class="number">0</span>: <span class="number">20</span>,</span><br><span class="line">            length: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        age: <span class="number">20</span>,</span><br><span class="line">        getAge: pointer to <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>),</span></span><br><span class="line"><span class="function">        <span class="title">name</span>: '<span class="title">Abby</span>',</span></span><br><span class="line"><span class="function">        <span class="title">getName</span>: <span class="title">pointer</span> <span class="title">to</span> <span class="title">function</span> <span class="title">getName</span>(<span class="params"></span>),</span></span><br><span class="line"><span class="function">    &#125;,</span></span><br><span class="line"><span class="function">    <span class="title">this</span>: </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="提升（Hoisting）"><a href="#提升（Hoisting）" class="headerlink" title="提升（Hoisting）"></a><strong>提升（Hoisting）</strong></h2><p>很多书上只说了变量提升是将变量提至当前上下文的最顶端，却未说明原因，现在理解了执行环境的创建、激活阶段，由此也可以解释函数、变量的提升了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> name); <span class="comment">// function</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> another); <span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'Abby'</span>,</span><br><span class="line">        another = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'Lucky'</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Abby'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> name); <span class="comment">// string</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> another); <span class="comment">// function</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<p><strong>此时的创建阶段的过程是:</strong></p>
<ol>
<li>函数name和其引用被存入到VO之中。</li>
<li>变量name发现在VO之中存在同名的属性，因此忽略。</li>
<li>变量another存入到VO之中，并赋值为undefined。(这也是函数表达式不会提升的原因)</li>
</ol>
<p><strong>此时代码从上到下执行的时候激活阶段的过程是:</strong></p>
<ol>
<li>console.log(typeof name); 此时name在VO中是函数。</li>
<li>console.log(typeof another); 此时another在VO中的值是undefined。</li>
<li>指出函数name的引用。</li>
<li>将name赋值为’hello’。</li>
<li>将another赋值为函数表达式的值。</li>
<li>console.log(typeof name); 此时的name由于被函数被字符串赋值覆盖因此是string类型。</li>
<li>console.log(typeof another); 此时的another被赋值成函数表达式因此是function类型。</li>
</ol>
<p>因此理解执行环境之后也就很好理解了为什么我们能在name声明之前访问它，为什么之后的name的类型值发生了变化，为什么another第一次打印的时候是undefined等等问题了。</p>
<hr>
<p>参考资料：<br><a href="http://link.zhihu.com/?target=http%3A//davidshariff.com/blog/what-is-the-execution-context-in-javascript/" target="_blank" rel="noopener">what-is-the-execution-context-in-javascript</a><br><a href="http://link.zhihu.com/?target=http%3A//yanhaijing.com/javascript/2014/04/29/what-is-the-execution-context-in-javascript/" target="_blank" rel="noopener">了解JavaScript的执行上下文</a><br><a href="http://link.zhihu.com/?target=http%3A//jibbering.com/faq/notes/closures/%23clIRExSc" target="_blank" rel="noopener">Identifier Resolution, Execution Contexts and scope chains</a><br><a href="http://link.zhihu.com/?target=http%3A//www.jianshu.com/p/a6d37c77e8db" target="_blank" rel="noopener">前端基础进阶（二）：执行上下文详细图解</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zxfred.github.io/2018/11/19/JavaScript中的执行环境/" data-id="cjqjg6fnw000fj8btupzfqiiv" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript中的with语句" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/19/JavaScript中的with语句/" class="article-date">
  <time datetime="2018-11-19T02:26:35.000Z" itemprop="datePublished">2018-11-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/19/JavaScript中的with语句/">JavaScript中的with语句</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>本文转载自网络</strong></p>
<p>JavaScript 有个 with 关键字，with 语句的原本用意是为逐级的对象访问提供命名空间式的速写方式。也就是在指定的代码区域，直接通过节点名称调用对象。</p>
<p>with语句的作用是暂时改变作用域链、减少的重复输入。</p>
<p>其语法结构为： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`with`</span><span class="string">`(object)&#123; `</span><span class="string">`//statements `</span><span class="string">`&#125;`</span></span><br></pre></td></tr></table></figure>
<p>实例： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`with`</span><span class="string">`(document.forms[])&#123; `</span><span class="string">`name.value = `</span><span class="string">`"lee king"`</span><span class="string">`; `</span><span class="string">`address.value = `</span><span class="string">`"Peking"`</span><span class="string">`; `</span><span class="string">`zipcode.value = `</span><span class="string">`""`</span><span class="string">`; `</span><span class="string">`&#125;`</span></span><br></pre></td></tr></table></figure>
<p>与之对应的传统的写法是： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`document.forms[].name.value = `</span><span class="string">`"lee king"`</span><span class="string">`; `</span><span class="string">`document.forms[].address.value = `</span><span class="string">`"Peking"`</span><span class="string">`; `</span><span class="string">`document.forms[].zipcode.value = `</span><span class="string">`""`</span><span class="string">`; `</span></span><br></pre></td></tr></table></figure>
<p>可以看出with语句的简洁明了，不过js的解释器需要检查with块中的变量是否属于with包含的对象，这将使with语句执行速度大大下降，并且导致js语句很难被优化。为了兼顾速度与代码量可以找到一个比较折衷的方案：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`var`</span> <span class="string">`form = document.forms[]; `</span><span class="string">`form.name.value = `</span><span class="string">`"lee king"`</span><span class="string">`; `</span><span class="string">`form.address.value = `</span><span class="string">`"Peking"`</span><span class="string">`; `</span><span class="string">`form.zipcode.value = `</span><span class="string">`""`</span><span class="string">`;`</span></span><br></pre></td></tr></table></figure>
<p><strong>在高效代码开发中应该尽可能的避免使用with语句</strong></p>
<p>在javascript中，函数也是对象。函数内部有一个只给javascript引擎访问的内部属性是[[scope]]，该属性包含了函数创建时的作用域中对象的集合，这个集合就叫做作用域链。 </p>
<p>在函数创建时，它的作用域链中会填入一个全局对象，该全局对象包含了所有全局变量。当函数被执行时，会创建一个<strong>活动对象</strong>，该对象包含了函数所有局部变量、命名参数以及this，然后该对象会被推入作用域链的前端，当函数执行完毕，该对象也随之销毁。</p>
<p>可以看到，全局变量会被活动对象推到作用域链的最后端，这也就是全局变量访问速度慢的原因</p>
<p>一般情况下，作用域链只会被with和catch语句影响。当使创建用with的时候，函数会创建一个新的活动对象，推到最前端，该对象就是with的对象。这就意味着所有的局部变量都处于第二个作用域链对象中去了，这也就是为什么要避免使用with的原因。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zxfred.github.io/2018/11/19/JavaScript中的with语句/" data-id="cjqjg6fnv000ej8bt4fagwdys" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript获取字符长度" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/15/JavaScript获取字符长度/" class="article-date">
  <time datetime="2018-11-15T08:48:10.000Z" itemprop="datePublished">2018-11-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/15/JavaScript获取字符长度/">JavaScript获取字符长度</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>计算字符串长度(英文占1个字符，中文汉字占2个字符)</p>
<p>方法一：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.gblen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> len = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.charCodeAt(i)&gt;<span class="number">127</span> || <span class="keyword">this</span>.charCodeAt(i)==<span class="number">94</span>) &#123;  </span><br><span class="line">            len += <span class="number">2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            len ++</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> len</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strlen</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;str.length; i++) &#123; </span><br><span class="line">        <span class="keyword">var</span> c = str.charCodeAt(i)</span><br><span class="line">        <span class="comment">//单字节加1 </span></span><br><span class="line">        <span class="keyword">if</span> ((c &gt;= <span class="number">0x0001</span> &amp;&amp; c &lt;= <span class="number">0x007e</span>) || (<span class="number">0xff60</span>&lt;=c &amp;&amp; c&lt;=<span class="number">0xff9f</span>)) &#123; </span><br><span class="line">            len++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            len+=<span class="number">2</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> len</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法三：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jmz = &#123;&#125;</span><br><span class="line">jmz.GetLength = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//&lt;summary&gt;获得字符串实际长度，中文2，英文1&lt;/summary&gt;</span></span><br><span class="line">    <span class="comment">//&lt;param name="str"&gt;要获得长度的字符串&lt;/param&gt;</span></span><br><span class="line">    <span class="keyword">var</span> realLength = <span class="number">0</span>, len = str.length, charCode = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        charCode = str.charCodeAt(i)</span><br><span class="line">        <span class="keyword">if</span> (charCode &gt;= <span class="number">0</span> &amp;&amp; charCode &lt;= <span class="number">128</span>) realLength += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span> realLength += <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> realLength</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法四：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> l = str.length</span><br><span class="line"><span class="keyword">var</span> blen = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;l; i++) &#123; </span><br><span class="line">    <span class="keyword">if</span> ((str.charCodeAt(i) &amp; <span class="number">0xff00</span>) != <span class="number">0</span>) &#123; </span><br><span class="line">        blen ++</span><br><span class="line">    &#125; </span><br><span class="line">    blen ++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法五：</p>
<p>把双字节的替换成两个单字节的然后再获得长度</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getBLen = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> str != <span class="string">"string"</span>)&#123;</span><br><span class="line">        str += <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.replace(<span class="regexp">/\x00-\xff/g</span>, <span class="string">"01"</span>).length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://zxfred.github.io/2018/11/15/JavaScript获取字符长度/" data-id="cjqjg6fnz000jj8bt4u5090cc" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript打乱数组" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/15/JavaScript打乱数组/" class="article-date">
  <time datetime="2018-11-15T03:23:54.000Z" itemprop="datePublished">2018-11-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/15/JavaScript打乱数组/">JavaScript打乱数组</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="使用sort"><a href="#使用sort" class="headerlink" title="使用sort"></a>使用sort</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.5</span> - <span class="built_in">Math</span>.random();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样使用 sort 的方法。某些场景下，这样的方法可以使用。但是<strong>这不是真正意义上的完全乱序，</strong>一些需求中（比如抽奖）这样的写法会出大问题。</p>
<p>lodash 库 _.shuffle 方法也是正解，翻开 lodash 源码相关部分，<strong>这个方法正是采用了 Fisher–Yates shuffle 洗牌算法</strong>。</p>
<hr>
<h3 id="为什么借助-sort-方法不是真正意义上的完全乱序？"><a href="#为什么借助-sort-方法不是真正意义上的完全乱序？" class="headerlink" title="为什么借助 sort 方法不是真正意义上的完全乱序？"></a>为什么借助 sort 方法不是真正意义上的完全乱序？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> letters = [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span>,<span class="string">'G'</span>,<span class="string">'H'</span>,<span class="string">'I'</span>,<span class="string">'J'</span>];</span><br></pre></td></tr></table></figure>
<p>letters 这样一个数组使用 array.sort  方法进行了 10000 次乱序处理，并把乱序的每一次结果可视化输出。每个元素（ABCD…）出现的位置次数进行记录:</p>
<p>不管点击按钮几次，都会发现整体乱序之后的结果<strong>绝对不是“完全随机”。</strong></p>
<p>比如 A 元素大概率出现在数组的头部，J 元素大概率出现在数组的尾部，<strong>所有元素大概率停留在自己初始位置。</strong></p>
<p><strong>究其原因，</strong>在<a href="https://link.zhihu.com/?target=https%3A//github.com/v8/v8/blob/master/src/js/array.js" target="_blank" rel="noopener">Chrome v8引擎源码中</a>，可以清晰看到，</p>
<blockquote>
<p>v8 在处理 sort 方法时，使用了插入排序和快排两种方案。当目标数组长度小于10时，使用插入排序；反之，使用快排。</p>
</blockquote>
<p>其实不管用什么排序方法，大多数排序算法的时间复杂度介于 O(n) 到 O(n2) 之间，元素之间的比较次数通常情况下要远小于 n(n-1)/2，也就意味着有一些元素之间根本就没机会相比较（也就没有了随机交换的可能），这些 sort 随机排序的算法自然也不能真正随机。 </p>
<p>通俗的说，其实我们使用 array.sort 进行乱序，理想的方案或者说纯乱序的方案是：数组中每两个元素都要进行比较，这个比较有 50% 的交换位置概率。如此一来，总共比较次数一定为 n(n-1)。</p>
<p>而在 sort 排序算法中，大多数情况都不会满足这样的条件。因而当然不是完全随机的结果了。</p>
<h3 id="Fisher–Yates-shuffle-洗牌算法是什么，为什么满足需求？"><a href="#Fisher–Yates-shuffle-洗牌算法是什么，为什么满足需求？" class="headerlink" title="Fisher–Yates shuffle 洗牌算法是什么，为什么满足需求？"></a>Fisher–Yates shuffle 洗牌算法是什么，为什么满足需求？</h3><h4 id="Step1："><a href="#Step1：" class="headerlink" title="Step1："></a>Step1：</h4><p>从数组末尾开始，选取最后一个元素</p>
<p>在数组一共 9 个位置中，随机产生一个位置，该位置元素与最后一个元素进行交换。</p>
<h4 id="Step2："><a href="#Step2：" class="headerlink" title="Step2："></a>Step2：</h4><p>上一步中，我们已经把数组末尾元素进行随机置换</p>
<p>接下来，对数组倒数第二个元素动手。在除去已经排好的最后一个元素位置以外的8个位置中，随机产生一个位置，该位置元素与倒数第二个元素进行交换。</p>
<h4 id="Step3："><a href="#Step3：" class="headerlink" title="Step3："></a>Step3：</h4><p>理解了前两步，接下来依次进行</p>
<p>最后实现代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.shuffle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> array = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> m = array.length,</span><br><span class="line">        t, i;</span><br><span class="line">    <span class="keyword">while</span> (m) &#123;</span><br><span class="line">        i = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * m--);</span><br><span class="line">        t = array[m];</span><br><span class="line">        array[m] = array[i];</span><br><span class="line">        array[i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://zxfred.github.io/2018/11/15/JavaScript打乱数组/" data-id="cjqjg6fnx000hj8btw4g5k7jk" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-git反向操作解决冲突" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/09/git反向操作解决冲突/" class="article-date">
  <time datetime="2018-11-09T08:19:04.000Z" itemprop="datePublished">2018-11-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/09/git反向操作解决冲突/">git反向操作解决冲突</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>merge 某开发分支代码到 DEPLOY 分支（部署到服务器的分支，有其他开发分支代码），提示代码冲突，无法 merge（实际上没有冲突，git判断有误）</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>因为开发分支不能拉取 DEPLOY 分支代码（会把其他分支的东西拉下来），可以切换到 DEPLOY 分支，拉取开发分支，解决冲突再提交</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zxfred.github.io/2018/11/09/git反向操作解决冲突/" data-id="cjqjg6fo9000yj8btjp2a1ikx" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-setTimeout代替setInterval" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/07/setTimeout代替setInterval/" class="article-date">
  <time datetime="2018-11-07T09:53:14.000Z" itemprop="datePublished">2018-11-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/07/setTimeout代替setInterval/">setTimeout代替setInterval</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let executeTimes = 0</span><br><span class="line">let intervalTime = 300</span><br><span class="line"></span><br><span class="line">setTimeout(function repeat() &#123;</span><br><span class="line">    executeTimes++;</span><br><span class="line">    </span><br><span class="line">    // do something</span><br><span class="line">    </span><br><span class="line">    if(executeTimes &lt; 50)&#123;</span><br><span class="line">        setTimeout(repeat,intervalTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, intervalTime)</span><br></pre></td></tr></table></figure>
<p>setInterval 有弊端，尽量避免使用</p>
<ul>
<li>无视代码错误</li>
<li>无视网络延迟</li>
<li>不保证执行</li>
</ul>
<p>如果确实要保证事件“匀速”被触发，那可以用希望的延迟减去上次调用所花时间，然后将得到的差值作为延迟动态指定给setTimeout。 不过，要注意的是JavaScript的计时器并不是非常精确[2]。因此你不可能得到绝对“平均”的延迟，即使使用setInterval也不行，原因很多（比如垃圾回收、JavaScript是单线程的，等等）。此外，当前浏览器也会将最小的超时时间固定在4ms到15ms之间。因此不要指望一点误差也没有。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zxfred.github.io/2018/11/07/setTimeout代替setInterval/" data-id="cjqjg6fod0015j8bt5t646zle" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-彻底理解JavaScript中的require、import与export" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/25/彻底理解JavaScript中的require、import与export/" class="article-date">
  <time datetime="2018-10-25T04:56:24.000Z" itemprop="datePublished">2018-10-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/25/彻底理解JavaScript中的require、import与export/">彻底理解JavaScript中的require、import与export</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>前言</strong></p>
<p>本文主要给大家介绍了关于javascript中require、import与export的相关内容，分享出来供大家参考学习，下面话不多说了，来一起看看详细的介绍吧。</p>
<p><strong>为什么有模块概念</strong></p>
<p>理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。</p>
<p>但是，Javascript不是一种模块化编程语言，在es6以前，它是不支持”类”（class），所以也就没有”模块”（module）了。</p>
<p><strong>require时代</strong></p>
<p>Javascript社区做了很多努力，在现有的运行环境中，实现”模块”的效果。</p>
<p><strong>原始写法</strong></p>
<p>模块就是实现特定功能的一组方法。<br>只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function m1()&#123;</span><br><span class="line">　//...</span><br><span class="line">&#125;</span><br><span class="line">function m2()&#123;</span><br><span class="line">　//...　　</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数<code>m1()</code>和<code>m2()</code> ，组成一个模块。使用的时候，直接调用就行了。</p>
<p>这种做法的缺点很明显：”污染”了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。</p>
<p><strong>对象写法</strong></p>
<p>为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var module1 = new Object(&#123;</span><br><span class="line">_count : 0,</span><br><span class="line">　m1 : function ()&#123;</span><br><span class="line">　　//...</span><br><span class="line">　&#125;,</span><br><span class="line">　m2 : function ()&#123;</span><br><span class="line">　　//...</span><br><span class="line">　&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的函数<code>m1()</code>和<code>m2()</code>，都封装在module1对象里。使用的时候，就是调用这个对象的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module1.m1();</span><br></pre></td></tr></table></figure>
<p>这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module._count = 1;</span><br></pre></td></tr></table></figure>
<p><strong>立即执行函数写法</strong></p>
<p>使用”立即执行函数”（Immediately-Invoked Function Expression，IIFE），可以达到不暴露私有成员的目的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var module = (function() &#123;</span><br><span class="line">var _count = 0;</span><br><span class="line">var m1 = function() &#123;</span><br><span class="line">alert(_count)</span><br><span class="line">&#125;</span><br><span class="line">var m2 = function() &#123;</span><br><span class="line">alert(_count + 1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return &#123;</span><br><span class="line">m1: m1,</span><br><span class="line">m2: m2</span><br><span class="line">&#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>使用上面的写法，外部代码无法读取内部的_count变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.info(module._count); //undefined</span><br></pre></td></tr></table></figure>
<p>module就是Javascript模块的基本写法。</p>
<p><strong>主流模块规范</strong></p>
<p>在es6以前，还没有提出一套官方的规范,从社区和框架推广程度而言,目前通行的javascript模块规范有两种：CommonJS 和 AMD</p>
<p><strong>CommonJS规范</strong></p>
<p>2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言用于服务器端编程。</p>
<p>这标志”Javascript模块化编程”正式诞生。前端的复杂程度有限，没有模块也是可以的，但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。</p>
<p>node编程中最重要的思想之一就是模块，而正是这个思想，让JavaScript的大规模工程成为可能。模块化编程在js界流行，也是基于此，随后在浏览器端，requirejs和seajs之类的工具包也出现了，可以说在对应规范下，require统治了ES6之前的所有模块化编程，即使现在，在ES6 module被完全实现之前，还是这样。</p>
<p>在CommonJS中,暴露模块使用<code>module.exports</code>和exports，很多人不明白暴露对象为什么会有两个,后面会介绍区别</p>
<p>在CommonJS中，有一个全局性方法<code>require()</code>，用于加载模块。假定有一个数学模块math.js，就可以像下面这样加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var math = require(&apos;math&apos;);</span><br></pre></td></tr></table></figure>
<p>然后，就可以调用模块提供的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　var math = require(&apos;math&apos;);</span><br><span class="line">　math.add(2,3); // 5</span><br></pre></td></tr></table></figure>
<p>正是由于CommonJS 使用的require方式的推动，才有了后面的AMD、CMD 也采用的require方式来引用模块的风格</p>
<p><strong>AMD规范</strong></p>
<p>有了服务器端模块以后，很自然地，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。</p>
<p>但是，由于一个重大的局限，使得CommonJS规范不适用于浏览器环境。还是上一节的代码，如果在浏览器中运行，会有一个很大的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var math = require(&apos;math&apos;);</span><br><span class="line">math.add(2, 3);</span><br></pre></td></tr></table></figure>
<p>第二行<code>math.add(2, 3)</code>，在第一行<code>require(‘math&#39;)</code>之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。</p>
<p>这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。</p>
<p>因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。</p>
<p>AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p>
<p>模块必须采用特定的<code>define()</code>函数来定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(id?, dependencies?, factory)</span><br></pre></td></tr></table></figure>
<ul>
<li>id:字符串，模块名称(可选)</li>
<li>dependencies: 是我们要载入的依赖模块(可选)，使用相对路径。,注意是数组格式</li>
<li>factory: 工厂方法，返回一个模块函数</li>
</ul>
<p>如果一个模块不依赖其他模块，那么可以直接定义在<code>define()</code>函数之中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// math.js</span><br><span class="line">　　define(function ()&#123;</span><br><span class="line">　　　　var add = function (x,y)&#123;</span><br><span class="line">　　　　　　return x+y;</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　　　return &#123;</span><br><span class="line">　　　　　　add: add</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>如果这个模块还依赖其他模块，那么<code>define()</code>函数的第一个参数，必须是一个数组，指明该模块的依赖性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define([&apos;Lib&apos;], function(Lib)&#123;</span><br><span class="line">　　　　function foo()&#123;</span><br><span class="line">　　　　　　Lib.doSomething();</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　return &#123;</span><br><span class="line">　　　　　　foo : foo</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>当<code>require()</code>函数加载上面这个模块的时候，就会先加载Lib.js文件。</p>
<p>AMD也采用<code>require()</code>语句加载模块，但是不同于CommonJS，它要求两个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require([module], callback);</span><br></pre></td></tr></table></figure>
<p>第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成AMD形式，就是下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require([&apos;math&apos;], function (math) &#123;</span><br><span class="line">　math.add(2, 3);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>math.add()与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。</p>
<p>目前，主要有两个Javascript库实现了AMD规范：<a href="http://requirejs.org/" target="_blank" rel="noopener">require.js</a>和<a href="http://cujojs.com/" target="_blank" rel="noopener">curl.js</a>。</p>
<p><strong>CMD规范</strong></p>
<p>CMD (Common Module Definition), 是seajs推崇的规范，CMD则是依赖就近，用的时候再require。它写起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">var clock = require(&apos;clock&apos;);</span><br><span class="line">clock.start();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>CMD与AMD一样，也是采用特定的<code>define()</code>函数来定义,用require方式来引用模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(id?, dependencies?, factory)</span><br></pre></td></tr></table></figure>
<ul>
<li>id:字符串，模块名称(可选)</li>
<li>dependencies: 是我们要载入的依赖模块(可选)，使用相对路径。,注意是数组格式</li>
<li>factory: 工厂方法，返回一个模块函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define(&apos;hello&apos;, [&apos;jquery&apos;], function(require, exports, module) &#123;</span><br><span class="line"></span><br><span class="line">// 模块代码</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果一个模块不依赖其他模块，那么可以直接定义在<code>define()</code>函数之中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">// 模块代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>带 id 和 dependencies 参数的 define 用法不属于 CMD 规范，而属于 Modules/Transport 规范。</p>
<p><strong>CMD与AMD区别</strong></p>
<p>AMD和CMD最大的区别是对依赖模块的执行时机处理不同，而不是加载的时机或者方式不同，二者皆为异步加载模块。</p>
<p>AMD依赖前置，js可以方便知道依赖模块是谁，立即加载；</p>
<p>而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。</p>
<p><strong>现阶段的标准</strong></p>
<p>ES6标准发布后，module成为标准，标准使用是以export指令导出接口，以import引入模块，但是在我们一贯的node模块中，我们依然采用的是CommonJS规范，使用require引入模块，使用module.exports导出接口。</p>
<p><strong>export导出模块</strong></p>
<p>export语法声明用于导出函数、对象、指定文件（或模块）的原始值。</p>
<p><strong>注意：</strong>在node中使用的是exports,不要混淆了</p>
<p>export有两种模块导出方式：命名式导出（名称导出）和默认导出（定义式导出），命名式导出每个模块可以多个，而默认导出每个模块仅一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export &#123; name1, name2, …, nameN &#125;;</span><br><span class="line">export &#123; variable1 as name1, variable2 as name2, …, nameN &#125;;</span><br><span class="line">export let name1, name2, …, nameN; // also var</span><br><span class="line">export let name1 = …, name2 = …, …, nameN; // also var, const</span><br><span class="line"></span><br><span class="line">export default expression;</span><br><span class="line">export default function (…) &#123; … &#125; // also class, function*</span><br><span class="line">export default function name1(…) &#123; … &#125; // also class, function*</span><br><span class="line">export &#123; name1 as default, … &#125;;</span><br><span class="line"></span><br><span class="line">export * from …;</span><br><span class="line">export &#123; name1, name2, …, nameN &#125; from …;</span><br><span class="line">export &#123; import1 as name1, import2 as name2, …, nameN &#125; from …;</span><br></pre></td></tr></table></figure>
<ul>
<li>name1… nameN－导出的“标识符”。导出后，可以通过这个“标识符”在另一个模块中使用import引用</li>
<li>default－设置模块的默认导出。设置后import不通过“标识符”而直接引用默认导入</li>
<li>－继承模块并导出继承模块所有的方法和属性</li>
<li>as－重命名导出“标识符”</li>
<li>from－从已经存在的模块、脚本文件…导出</li>
</ul>
<p><strong>命名式导出</strong></p>
<p>模块可以通过export前缀关键词声明导出对象，导出对象可以是多个。这些导出对象用名称进行区分，称之为命名式导出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export &#123; myFunction &#125;; // 导出一个已定义的函数</span><br><span class="line">export const foo = Math.sqrt(2); // 导出一个常量</span><br></pre></td></tr></table></figure>
<p>我们可以使用*和from关键字来实现的模块的继承：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export * from &apos;article&apos;;</span><br></pre></td></tr></table></figure>
<p>模块导出时，可以指定模块的导出成员。导出成员可以认为是类中的公有对象，而非导出成员可以认为是类中的私有对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;IT笔录&apos;;</span><br><span class="line">var domain = &apos;http://itbilu.com&apos;;</span><br><span class="line"></span><br><span class="line">export &#123;name, domain&#125;; // 相当于导出</span><br><span class="line">&#123;name:name,domain:domain&#125;</span><br></pre></td></tr></table></figure>
<p>模块导出时，我们可以使用as关键字对导出成员进行重命名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;IT笔录&apos;;</span><br><span class="line">var domain = &apos;http://itbilu.com&apos;;</span><br><span class="line"></span><br><span class="line">export &#123;name as siteName, domain&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>下面的语法有严重错误的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 错误演示</span><br><span class="line">export 1; // 绝对不可以</span><br><span class="line"></span><br><span class="line">var a = 100;</span><br><span class="line">export a;</span><br></pre></td></tr></table></figure>
<p>export在导出接口的时候，必须与模块内部的变量具有一一对应的关系。直接导出1没有任何意义，也不可能在import的时候有一个变量与之对应</p>
<p>export a虽然看上去成立，但是a的值是一个数字，根本无法完成解构，因此必须写成export {a}的形式。即使a被赋值为一个function，也是不允许的。而且，大部分风格都建议，模块中最好在末尾用一个export导出所有的接口，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export &#123;fun as default,a,b,c&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>默认导出</strong></p>
<p>默认导出也被称做定义式导出。命名式导出可以导出多个值，但在在import引用时，也要使用相同的名称来引用相应的值。而默认导出每个导出只有一个单一值，这个输出可以是一个函数、类或其它类型的值，这样在模块import导入时也会很容易引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export default function() &#123;&#125;; // 可以导出一个函数</span><br><span class="line">export default class()&#123;&#125;; // 也可以出一个类</span><br></pre></td></tr></table></figure>
<p><strong>命名式导出与默认导出</strong></p>
<p>默认导出可以理解为另一种形式的命名导出，默认导出可以认为是使用了default名称的命名导出。</p>
<p>下面两种导出方式是等价的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const D = 123;</span><br><span class="line"></span><br><span class="line">export default D;</span><br><span class="line">export &#123; D as default &#125;;</span><br></pre></td></tr></table></figure>
<p><strong>export使用示例</strong></p>
<p>使用名称导出一个模块时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// &quot;my-module.js&quot; 模块</span><br><span class="line">export function cube(x) &#123;</span><br><span class="line">return x * x * x;</span><br><span class="line">&#125;</span><br><span class="line">const foo = Math.PI + Math.SQRT2;</span><br><span class="line">export &#123; foo &#125;;</span><br></pre></td></tr></table></figure>
<p>在另一个模块（脚本文件）中，我们可以像下面这样引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; cube, foo &#125; from &apos;my-module&apos;;</span><br><span class="line">console.log(cube(3)); // 27</span><br><span class="line">console.log(foo); // 4.555806215962888</span><br></pre></td></tr></table></figure>
<p>使用默认导出一个模块时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// &quot;my-module.js&quot;模块</span><br><span class="line">export default function (x) &#123;</span><br><span class="line">return x * x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在另一个模块（脚本文件）中，我们可以像下面这样引用，相对名称导出来说使用更为简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 引用 &quot;my-module.js&quot;模块</span><br><span class="line">import cube from &apos;my-module&apos;;</span><br><span class="line">console.log(cube(3)); // 27</span><br></pre></td></tr></table></figure>
<p><strong>import引入模块</strong></p>
<p>import语法声明用于从已导出的模块、脚本中导入函数、对象、指定文件（或模块）的原始值。</p>
<p>import模块导入与export模块导出功能相对应，也存在两种模块导入方式：命名式导入（名称导入）和默认导入（定义式导入）。</p>
<p>import的语法跟require不同，而且import必须放在文件的最开始，且前面不允许有其他逻辑代码，这和其他所有编程语言风格一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import defaultMember from &quot;module-name&quot;;</span><br><span class="line">import * as name from &quot;module-name&quot;;</span><br><span class="line">import &#123; member &#125; from &quot;module-name&quot;;</span><br><span class="line">import &#123; member as alias &#125; from &quot;module-name&quot;;</span><br><span class="line">import &#123; member1 , member2 &#125; from &quot;module-name&quot;;</span><br><span class="line">import &#123; member1 , member2 as alias2 , [...] &#125; from &quot;module-name&quot;;</span><br><span class="line">import defaultMember, &#123; member [ , [...] ] &#125; from &quot;module-name&quot;;</span><br><span class="line">import defaultMember, * as name from &quot;module-name&quot;;</span><br><span class="line">import &quot;module-name&quot;;</span><br></pre></td></tr></table></figure>
<ul>
<li>name－从将要导入模块中收到的导出值的名称</li>
<li>member, memberN－从导出模块，导入指定名称的多个成员</li>
<li>defaultMember－从导出模块，导入默认导出成员</li>
<li>alias, aliasN－别名，对指定导入成员进行的重命名</li>
<li>module-name－要导入的模块。是一个文件名</li>
<li>as－重命名导入成员名称（“标识符”）</li>
<li>from－从已经存在的模块、脚本文件等导入</li>
</ul>
<p><strong>命名式导入</strong></p>
<p>我们可以通过指定名称，就是将这些成员插入到当作用域中。导出时，可以导入单个成员或多个成员：</p>
<p><strong>注意：</strong>花括号里面的变量与export后面的变量一一对应</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123;myMember&#125; from &quot;my-module&quot;;</span><br><span class="line">import &#123;foo, bar&#125; from &quot;my-module&quot;;</span><br></pre></td></tr></table></figure>
<p>通过*符号，我们可以导入模块中的全部属性和方法。当导入模块全部导出内容时，就是将导出模块（’my-module.js’）所有的导出绑定内容，插入到当前模块（’myModule’）的作用域中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import * as myModule from &quot;my-module&quot;;</span><br></pre></td></tr></table></figure>
<p>导入模块对象时，也可以使用as对导入成员重命名，以方便在当前模块内使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;reallyReallyLongModuleMemberName as shortName&#125; from &quot;my-module&quot;;</span><br></pre></td></tr></table></figure>
<p>导入多个成员时，同样可以使用别名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;reallyReallyLongModuleMemberName as shortName, anotherLongModuleName as short&#125; from &quot;my-module&quot;;</span><br></pre></td></tr></table></figure>
<p>导入一个模块，但不进行任何绑定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;my-module&quot;;</span><br></pre></td></tr></table></figure>
<p><strong>默认导入</strong></p>
<p>在模块导出时，可能会存在默认导出。同样的，在导入时可以使用import指令导出这些默认值。</p>
<p>直接导入默认值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import myDefault from &quot;my-module&quot;;</span><br></pre></td></tr></table></figure>
<p>也可以在命名空间导入和名称导入中，同时使用默认导入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import myDefault, * as myModule from &quot;my-module&quot;; // myModule 做为命名空间使用</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import myDefault, &#123;foo, bar&#125; from &quot;my-module&quot;; // 指定成员导入</span><br></pre></td></tr></table></figure>
<p>import使用示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// --file.js--</span><br><span class="line">function getJSON(url, callback) &#123;</span><br><span class="line">let xhr = new XMLHttpRequest();</span><br><span class="line">xhr.onload = function () &#123;</span><br><span class="line">callback(this.responseText)</span><br><span class="line">&#125;;</span><br><span class="line">xhr.open(&quot;GET&quot;, url, true);</span><br><span class="line">xhr.send();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function getUsefulContents(url, callback) &#123;</span><br><span class="line">getJSON(url, data =&gt; callback(JSON.parse(data)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// --main.js--</span><br><span class="line">import &#123; getUsefulContents &#125; from &quot;file&quot;;</span><br><span class="line">getUsefulContents(&quot;http://itbilu.com&quot;, data =&gt; &#123;</span><br><span class="line">doSomethingUseful(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>default关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// d.js</span><br><span class="line">export default function() &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 等效于：</span><br><span class="line">function a() &#123;&#125;;</span><br><span class="line">export &#123;a as default&#125;;</span><br></pre></td></tr></table></figure>
<p>在import的时候，可以这样用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import a from &apos;./d&apos;;</span><br><span class="line"></span><br><span class="line">// 等效于，或者说就是下面这种写法的简写，是同一个意思</span><br><span class="line">import &#123;default as a&#125; from &apos;./d&apos;;</span><br></pre></td></tr></table></figure>
<p>这个语法糖的好处就是import的时候，可以省去花括号{}。</p>
<p>简单的说，如果import的时候，你发现某个变量没有花括号括起来（没有*号），那么你在脑海中应该把它还原成有花括号的as语法。</p>
<p>所以，下面这种写法你也应该理解了吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import $,&#123;each,map&#125; from &apos;jquery&apos;;</span><br></pre></td></tr></table></figure>
<p>import后面第一个$是<code>{defalut as $}</code>的替代写法。</p>
<p><strong>as关键字</strong></p>
<p>as简单的说就是取一个别名,export中可以用，import中其实可以用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// a.js</span><br><span class="line">var a = function() &#123;&#125;;</span><br><span class="line">export &#123;a as fun&#125;;</span><br><span class="line"></span><br><span class="line">// b.js</span><br><span class="line">import &#123;fun as a&#125; from &apos;./a&apos;;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure>
<p>上面这段代码，export的时候，对外提供的接口是fun，它是a.js内部a这个函数的别名，但是在模块外面，认不到a，只能认到fun。</p>
<p>import中的as就很简单，就是你在使用模块里面的方法的时候，给这个方法取一个别名，好在当前的文件里面使用。之所以是这样，是因为有的时候不同的两个模块可能通过相同的接口，比如有一个c.js也通过了fun这个接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// c.js</span><br><span class="line">export function fun() &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>如果在b.js中同时使用a和c这两个模块，就必须想办法解决接口重名的问题，as就解决了。</p>
<p><strong>CommonJS中module.exports 与 exports的区别</strong></p>
<p><strong>Module.exports</strong></p>
<p>The module.exports object is created by the Module system. Sometimes this is not acceptable; many want their module to be an instance of some class. To do this, assign the desired export object to module.exports. Note that assigning the desired object to exports will simply rebind the local exports variable, which is probably not what you want to do.</p>
<p>译文：module.exports对象是由模块系统创建的。 有时这是难以接受的；许多人希望他们的模块成为某个类的实例。 为了实现这个，需要将期望导出的对象赋值给module.exports。 注意，将期望的对象赋值给exports会简单地重新绑定到本地exports变量上，这可能不是你想要的。</p>
<p><strong>Module.exports</strong></p>
<p>The exports variable is available within a module’s file-level scope, and is assigned the value of module.exports before the module is evaluated. It allows a shortcut, so that module.exports.f = … can be written more succinctly as exports.f = …. However, be aware that like any variable, if a new value is assigned to exports, it is no longer bound to module.exports:</p>
<p>译文：exports变量是在模块的文件级别作用域内有效的，它在模块被执行前被赋于<code>module.exports</code> 的值。它有一个快捷方式，以便 <code>module.exports.f = …</code>可以被更简洁地写成<code>exports.f = …</code>。 注意，就像任何变量，如果一个新的值被赋值给exports，它就不再绑定到<code>module.exports</code>(其实是exports.属性会自动挂载到没有命名冲突的module.exports.属性)</p>
<p>从<a href="http://nodejs.cn/api/modules.html#modules_module_exports" target="_blank" rel="noopener">Api文档</a>上面的可以看出，从require导入方式去理解，关键有两个变量(全局变量module.exports，局部变量exports)、一个返回值(module.exports)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function require(...) &#123;</span><br><span class="line">var module = &#123; exports: &#123;&#125; &#125;;</span><br><span class="line">((module, exports) =&gt; &#123;</span><br><span class="line">// 你的被引入代码 Start</span><br><span class="line">// var exports = module.exports = &#123;&#125;; (默认都有的)</span><br><span class="line">function some_func() &#123;&#125;;</span><br><span class="line">exports = some_func;</span><br><span class="line">// 此时，exports不再挂载到module.exports，</span><br><span class="line">// export将导出&#123;&#125;默认对象</span><br><span class="line">module.exports = some_func;</span><br><span class="line">// 此时，这个模块将导出some_func对象，覆盖exports上的some_func</span><br><span class="line">// 你的被引入代码 End</span><br><span class="line">&#125;)(module, module.exports);</span><br><span class="line">// 不管是exports还是module.exports，最后返回的还是module.exports</span><br><span class="line">return module.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>demo.js:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">console.log(exports); // &#123;&#125;</span><br><span class="line">console.log(module.exports); // &#123;&#125;</span><br><span class="line">console.log(exports === module.exports); // true</span><br><span class="line">console.log(exports == module.exports); // true</span><br><span class="line">console.log(module);</span><br><span class="line">/**</span><br><span class="line">Module &#123;</span><br><span class="line">id: &apos;.&apos;,</span><br><span class="line">exports: &#123;&#125;,</span><br><span class="line">parent: null,</span><br><span class="line">filename: &apos;/Users/larben/Desktop/demo.js&apos;,</span><br><span class="line">loaded: false,</span><br><span class="line">children: [],</span><br><span class="line">paths:</span><br><span class="line">[ &apos;/Users/larben/Desktop/node_modules&apos;,</span><br><span class="line">&apos;/Users/larben/node_modules&apos;,</span><br><span class="line">&apos;/Users/node_modules&apos;,</span><br><span class="line">&apos;/node_modules&apos; ] &#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>每个js文件一创建，都有一个<code>var exports = module.exports = {}</code> , 使exports和<code>module.exports</code>都指向一个空对象。</p>
<p><code>module.exports</code>和exports所指向的内存地址相同</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zxfred.github.io/2018/10/25/彻底理解JavaScript中的require、import与export/" data-id="cjqjg6fpb0020j8bthqxy14kl" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; zurück</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序-Vue/">微信小程序 Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 13.33px;">CSS</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/微信小程序/" style="font-size: 10px;">微信小程序</a> <a href="/tags/微信小程序-Vue/" style="font-size: 10px;">微信小程序 Vue</a> <a href="/tags/数据结构/" style="font-size: 16.67px;">数据结构</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/05/正则表达式中常用flags含义/">正则表达式中常用flags含义</a>
          </li>
        
          <li>
            <a href="/2019/01/01/一些命令行操作/">一些命令行操作</a>
          </li>
        
          <li>
            <a href="/2018/12/27/vscode环境变量/">vscode环境变量</a>
          </li>
        
          <li>
            <a href="/2018/12/19/npm参考手册/">npm参考手册</a>
          </li>
        
          <li>
            <a href="/2018/12/18/package-json解读/">package.json中文文档</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Fred Zhang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>
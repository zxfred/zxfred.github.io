<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Acidic Accident</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Acidic Accident">
<meta property="og:url" content="http://zxfred.github.io/page/2/index.html">
<meta property="og:site_name" content="Acidic Accident">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Acidic Accident">
  
    <link rel="alternate" href="/atom.xml" title="Acidic Accident" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Acidic Accident</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://zxfred.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-setTimeout代替setInterval" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/07/setTimeout代替setInterval/" class="article-date">
  <time datetime="2018-11-07T09:53:14.000Z" itemprop="datePublished">2018-11-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/07/setTimeout代替setInterval/">setTimeout代替setInterval</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let executeTimes = 0</span><br><span class="line">let intervalTime = 300</span><br><span class="line"></span><br><span class="line">setTimeout(function repeat() &#123;</span><br><span class="line">    executeTimes++;</span><br><span class="line">    </span><br><span class="line">    // do something</span><br><span class="line">    </span><br><span class="line">    if(executeTimes &lt; 50)&#123;</span><br><span class="line">        setTimeout(repeat,intervalTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, intervalTime)</span><br></pre></td></tr></table></figure>
<p>setInterval 有弊端，尽量避免使用</p>
<ul>
<li>无视代码错误</li>
<li>无视网络延迟</li>
<li>不保证执行</li>
</ul>
<p>如果确实要保证事件“匀速”被触发，那可以用希望的延迟减去上次调用所花时间，然后将得到的差值作为延迟动态指定给setTimeout。 不过，要注意的是JavaScript的计时器并不是非常精确[2]。因此你不可能得到绝对“平均”的延迟，即使使用setInterval也不行，原因很多（比如垃圾回收、JavaScript是单线程的，等等）。此外，当前浏览器也会将最小的超时时间固定在4ms到15ms之间。因此不要指望一点误差也没有。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zxfred.github.io/2018/11/07/setTimeout代替setInterval/" data-id="cjozrddh10010qzzc7rovqer3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-彻底理解JavaScript中的require、import与export" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/25/彻底理解JavaScript中的require、import与export/" class="article-date">
  <time datetime="2018-10-25T04:56:24.000Z" itemprop="datePublished">2018-10-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/25/彻底理解JavaScript中的require、import与export/">彻底理解JavaScript中的require、import与export</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>前言</strong></p>
<p>本文主要给大家介绍了关于javascript中require、import与export的相关内容，分享出来供大家参考学习，下面话不多说了，来一起看看详细的介绍吧。</p>
<p><strong>为什么有模块概念</strong></p>
<p>理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。</p>
<p>但是，Javascript不是一种模块化编程语言，在es6以前，它是不支持”类”（class），所以也就没有”模块”（module）了。</p>
<p><strong>require时代</strong></p>
<p>Javascript社区做了很多努力，在现有的运行环境中，实现”模块”的效果。</p>
<p><strong>原始写法</strong></p>
<p>模块就是实现特定功能的一组方法。<br>只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function m1()&#123;</span><br><span class="line">　//...</span><br><span class="line">&#125;</span><br><span class="line">function m2()&#123;</span><br><span class="line">　//...　　</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数<code>m1()</code>和<code>m2()</code> ，组成一个模块。使用的时候，直接调用就行了。</p>
<p>这种做法的缺点很明显：”污染”了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。</p>
<p><strong>对象写法</strong></p>
<p>为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var module1 = new Object(&#123;</span><br><span class="line">_count : 0,</span><br><span class="line">　m1 : function ()&#123;</span><br><span class="line">　　//...</span><br><span class="line">　&#125;,</span><br><span class="line">　m2 : function ()&#123;</span><br><span class="line">　　//...</span><br><span class="line">　&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的函数<code>m1()</code>和<code>m2()</code>，都封装在module1对象里。使用的时候，就是调用这个对象的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module1.m1();</span><br></pre></td></tr></table></figure>
<p>这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module._count = 1;</span><br></pre></td></tr></table></figure>
<p><strong>立即执行函数写法</strong></p>
<p>使用”立即执行函数”（Immediately-Invoked Function Expression，IIFE），可以达到不暴露私有成员的目的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var module = (function() &#123;</span><br><span class="line">var _count = 0;</span><br><span class="line">var m1 = function() &#123;</span><br><span class="line">alert(_count)</span><br><span class="line">&#125;</span><br><span class="line">var m2 = function() &#123;</span><br><span class="line">alert(_count + 1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return &#123;</span><br><span class="line">m1: m1,</span><br><span class="line">m2: m2</span><br><span class="line">&#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>使用上面的写法，外部代码无法读取内部的_count变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.info(module._count); //undefined</span><br></pre></td></tr></table></figure>
<p>module就是Javascript模块的基本写法。</p>
<p><strong>主流模块规范</strong></p>
<p>在es6以前，还没有提出一套官方的规范,从社区和框架推广程度而言,目前通行的javascript模块规范有两种：CommonJS 和 AMD</p>
<p><strong>CommonJS规范</strong></p>
<p>2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言用于服务器端编程。</p>
<p>这标志”Javascript模块化编程”正式诞生。前端的复杂程度有限，没有模块也是可以的，但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。</p>
<p>node编程中最重要的思想之一就是模块，而正是这个思想，让JavaScript的大规模工程成为可能。模块化编程在js界流行，也是基于此，随后在浏览器端，requirejs和seajs之类的工具包也出现了，可以说在对应规范下，require统治了ES6之前的所有模块化编程，即使现在，在ES6 module被完全实现之前，还是这样。</p>
<p>在CommonJS中,暴露模块使用<code>module.exports</code>和exports，很多人不明白暴露对象为什么会有两个,后面会介绍区别</p>
<p>在CommonJS中，有一个全局性方法<code>require()</code>，用于加载模块。假定有一个数学模块math.js，就可以像下面这样加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var math = require(&apos;math&apos;);</span><br></pre></td></tr></table></figure>
<p>然后，就可以调用模块提供的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　var math = require(&apos;math&apos;);</span><br><span class="line">　math.add(2,3); // 5</span><br></pre></td></tr></table></figure>
<p>正是由于CommonJS 使用的require方式的推动，才有了后面的AMD、CMD 也采用的require方式来引用模块的风格</p>
<p><strong>AMD规范</strong></p>
<p>有了服务器端模块以后，很自然地，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。</p>
<p>但是，由于一个重大的局限，使得CommonJS规范不适用于浏览器环境。还是上一节的代码，如果在浏览器中运行，会有一个很大的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var math = require(&apos;math&apos;);</span><br><span class="line">math.add(2, 3);</span><br></pre></td></tr></table></figure>
<p>第二行<code>math.add(2, 3)</code>，在第一行<code>require(‘math&#39;)</code>之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。</p>
<p>这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。</p>
<p>因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。</p>
<p>AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p>
<p>模块必须采用特定的<code>define()</code>函数来定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(id?, dependencies?, factory)</span><br></pre></td></tr></table></figure>
<ul>
<li>id:字符串，模块名称(可选)</li>
<li>dependencies: 是我们要载入的依赖模块(可选)，使用相对路径。,注意是数组格式</li>
<li>factory: 工厂方法，返回一个模块函数</li>
</ul>
<p>如果一个模块不依赖其他模块，那么可以直接定义在<code>define()</code>函数之中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// math.js</span><br><span class="line">　　define(function ()&#123;</span><br><span class="line">　　　　var add = function (x,y)&#123;</span><br><span class="line">　　　　　　return x+y;</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　　　return &#123;</span><br><span class="line">　　　　　　add: add</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>如果这个模块还依赖其他模块，那么<code>define()</code>函数的第一个参数，必须是一个数组，指明该模块的依赖性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define([&apos;Lib&apos;], function(Lib)&#123;</span><br><span class="line">　　　　function foo()&#123;</span><br><span class="line">　　　　　　Lib.doSomething();</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　return &#123;</span><br><span class="line">　　　　　　foo : foo</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>当<code>require()</code>函数加载上面这个模块的时候，就会先加载Lib.js文件。</p>
<p>AMD也采用<code>require()</code>语句加载模块，但是不同于CommonJS，它要求两个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require([module], callback);</span><br></pre></td></tr></table></figure>
<p>第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成AMD形式，就是下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require([&apos;math&apos;], function (math) &#123;</span><br><span class="line">　math.add(2, 3);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>math.add()与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。</p>
<p>目前，主要有两个Javascript库实现了AMD规范：<a href="http://requirejs.org/" target="_blank" rel="noopener">require.js</a>和<a href="http://cujojs.com/" target="_blank" rel="noopener">curl.js</a>。</p>
<p><strong>CMD规范</strong></p>
<p>CMD (Common Module Definition), 是seajs推崇的规范，CMD则是依赖就近，用的时候再require。它写起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">var clock = require(&apos;clock&apos;);</span><br><span class="line">clock.start();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>CMD与AMD一样，也是采用特定的<code>define()</code>函数来定义,用require方式来引用模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(id?, dependencies?, factory)</span><br></pre></td></tr></table></figure>
<ul>
<li>id:字符串，模块名称(可选)</li>
<li>dependencies: 是我们要载入的依赖模块(可选)，使用相对路径。,注意是数组格式</li>
<li>factory: 工厂方法，返回一个模块函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define(&apos;hello&apos;, [&apos;jquery&apos;], function(require, exports, module) &#123;</span><br><span class="line"></span><br><span class="line">// 模块代码</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果一个模块不依赖其他模块，那么可以直接定义在<code>define()</code>函数之中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">// 模块代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>带 id 和 dependencies 参数的 define 用法不属于 CMD 规范，而属于 Modules/Transport 规范。</p>
<p><strong>CMD与AMD区别</strong></p>
<p>AMD和CMD最大的区别是对依赖模块的执行时机处理不同，而不是加载的时机或者方式不同，二者皆为异步加载模块。</p>
<p>AMD依赖前置，js可以方便知道依赖模块是谁，立即加载；</p>
<p>而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。</p>
<p><strong>现阶段的标准</strong></p>
<p>ES6标准发布后，module成为标准，标准使用是以export指令导出接口，以import引入模块，但是在我们一贯的node模块中，我们依然采用的是CommonJS规范，使用require引入模块，使用module.exports导出接口。</p>
<p><strong>export导出模块</strong></p>
<p>export语法声明用于导出函数、对象、指定文件（或模块）的原始值。</p>
<p><strong>注意：</strong>在node中使用的是exports,不要混淆了</p>
<p>export有两种模块导出方式：命名式导出（名称导出）和默认导出（定义式导出），命名式导出每个模块可以多个，而默认导出每个模块仅一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export &#123; name1, name2, …, nameN &#125;;</span><br><span class="line">export &#123; variable1 as name1, variable2 as name2, …, nameN &#125;;</span><br><span class="line">export let name1, name2, …, nameN; // also var</span><br><span class="line">export let name1 = …, name2 = …, …, nameN; // also var, const</span><br><span class="line"></span><br><span class="line">export default expression;</span><br><span class="line">export default function (…) &#123; … &#125; // also class, function*</span><br><span class="line">export default function name1(…) &#123; … &#125; // also class, function*</span><br><span class="line">export &#123; name1 as default, … &#125;;</span><br><span class="line"></span><br><span class="line">export * from …;</span><br><span class="line">export &#123; name1, name2, …, nameN &#125; from …;</span><br><span class="line">export &#123; import1 as name1, import2 as name2, …, nameN &#125; from …;</span><br></pre></td></tr></table></figure>
<ul>
<li>name1… nameN－导出的“标识符”。导出后，可以通过这个“标识符”在另一个模块中使用import引用</li>
<li>default－设置模块的默认导出。设置后import不通过“标识符”而直接引用默认导入</li>
<li>－继承模块并导出继承模块所有的方法和属性</li>
<li>as－重命名导出“标识符”</li>
<li>from－从已经存在的模块、脚本文件…导出</li>
</ul>
<p><strong>命名式导出</strong></p>
<p>模块可以通过export前缀关键词声明导出对象，导出对象可以是多个。这些导出对象用名称进行区分，称之为命名式导出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export &#123; myFunction &#125;; // 导出一个已定义的函数</span><br><span class="line">export const foo = Math.sqrt(2); // 导出一个常量</span><br></pre></td></tr></table></figure>
<p>我们可以使用*和from关键字来实现的模块的继承：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export * from &apos;article&apos;;</span><br></pre></td></tr></table></figure>
<p>模块导出时，可以指定模块的导出成员。导出成员可以认为是类中的公有对象，而非导出成员可以认为是类中的私有对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;IT笔录&apos;;</span><br><span class="line">var domain = &apos;http://itbilu.com&apos;;</span><br><span class="line"></span><br><span class="line">export &#123;name, domain&#125;; // 相当于导出</span><br><span class="line">&#123;name:name,domain:domain&#125;</span><br></pre></td></tr></table></figure>
<p>模块导出时，我们可以使用as关键字对导出成员进行重命名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;IT笔录&apos;;</span><br><span class="line">var domain = &apos;http://itbilu.com&apos;;</span><br><span class="line"></span><br><span class="line">export &#123;name as siteName, domain&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>下面的语法有严重错误的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 错误演示</span><br><span class="line">export 1; // 绝对不可以</span><br><span class="line"></span><br><span class="line">var a = 100;</span><br><span class="line">export a;</span><br></pre></td></tr></table></figure>
<p>export在导出接口的时候，必须与模块内部的变量具有一一对应的关系。直接导出1没有任何意义，也不可能在import的时候有一个变量与之对应</p>
<p>export a虽然看上去成立，但是a的值是一个数字，根本无法完成解构，因此必须写成export {a}的形式。即使a被赋值为一个function，也是不允许的。而且，大部分风格都建议，模块中最好在末尾用一个export导出所有的接口，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export &#123;fun as default,a,b,c&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>默认导出</strong></p>
<p>默认导出也被称做定义式导出。命名式导出可以导出多个值，但在在import引用时，也要使用相同的名称来引用相应的值。而默认导出每个导出只有一个单一值，这个输出可以是一个函数、类或其它类型的值，这样在模块import导入时也会很容易引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export default function() &#123;&#125;; // 可以导出一个函数</span><br><span class="line">export default class()&#123;&#125;; // 也可以出一个类</span><br></pre></td></tr></table></figure>
<p><strong>命名式导出与默认导出</strong></p>
<p>默认导出可以理解为另一种形式的命名导出，默认导出可以认为是使用了default名称的命名导出。</p>
<p>下面两种导出方式是等价的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const D = 123;</span><br><span class="line"></span><br><span class="line">export default D;</span><br><span class="line">export &#123; D as default &#125;;</span><br></pre></td></tr></table></figure>
<p><strong>export使用示例</strong></p>
<p>使用名称导出一个模块时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// &quot;my-module.js&quot; 模块</span><br><span class="line">export function cube(x) &#123;</span><br><span class="line">return x * x * x;</span><br><span class="line">&#125;</span><br><span class="line">const foo = Math.PI + Math.SQRT2;</span><br><span class="line">export &#123; foo &#125;;</span><br></pre></td></tr></table></figure>
<p>在另一个模块（脚本文件）中，我们可以像下面这样引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; cube, foo &#125; from &apos;my-module&apos;;</span><br><span class="line">console.log(cube(3)); // 27</span><br><span class="line">console.log(foo); // 4.555806215962888</span><br></pre></td></tr></table></figure>
<p>使用默认导出一个模块时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// &quot;my-module.js&quot;模块</span><br><span class="line">export default function (x) &#123;</span><br><span class="line">return x * x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在另一个模块（脚本文件）中，我们可以像下面这样引用，相对名称导出来说使用更为简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 引用 &quot;my-module.js&quot;模块</span><br><span class="line">import cube from &apos;my-module&apos;;</span><br><span class="line">console.log(cube(3)); // 27</span><br></pre></td></tr></table></figure>
<p><strong>import引入模块</strong></p>
<p>import语法声明用于从已导出的模块、脚本中导入函数、对象、指定文件（或模块）的原始值。</p>
<p>import模块导入与export模块导出功能相对应，也存在两种模块导入方式：命名式导入（名称导入）和默认导入（定义式导入）。</p>
<p>import的语法跟require不同，而且import必须放在文件的最开始，且前面不允许有其他逻辑代码，这和其他所有编程语言风格一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import defaultMember from &quot;module-name&quot;;</span><br><span class="line">import * as name from &quot;module-name&quot;;</span><br><span class="line">import &#123; member &#125; from &quot;module-name&quot;;</span><br><span class="line">import &#123; member as alias &#125; from &quot;module-name&quot;;</span><br><span class="line">import &#123; member1 , member2 &#125; from &quot;module-name&quot;;</span><br><span class="line">import &#123; member1 , member2 as alias2 , [...] &#125; from &quot;module-name&quot;;</span><br><span class="line">import defaultMember, &#123; member [ , [...] ] &#125; from &quot;module-name&quot;;</span><br><span class="line">import defaultMember, * as name from &quot;module-name&quot;;</span><br><span class="line">import &quot;module-name&quot;;</span><br></pre></td></tr></table></figure>
<ul>
<li>name－从将要导入模块中收到的导出值的名称</li>
<li>member, memberN－从导出模块，导入指定名称的多个成员</li>
<li>defaultMember－从导出模块，导入默认导出成员</li>
<li>alias, aliasN－别名，对指定导入成员进行的重命名</li>
<li>module-name－要导入的模块。是一个文件名</li>
<li>as－重命名导入成员名称（“标识符”）</li>
<li>from－从已经存在的模块、脚本文件等导入</li>
</ul>
<p><strong>命名式导入</strong></p>
<p>我们可以通过指定名称，就是将这些成员插入到当作用域中。导出时，可以导入单个成员或多个成员：</p>
<p><strong>注意：</strong>花括号里面的变量与export后面的变量一一对应</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123;myMember&#125; from &quot;my-module&quot;;</span><br><span class="line">import &#123;foo, bar&#125; from &quot;my-module&quot;;</span><br></pre></td></tr></table></figure>
<p>通过*符号，我们可以导入模块中的全部属性和方法。当导入模块全部导出内容时，就是将导出模块（’my-module.js’）所有的导出绑定内容，插入到当前模块（’myModule’）的作用域中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import * as myModule from &quot;my-module&quot;;</span><br></pre></td></tr></table></figure>
<p>导入模块对象时，也可以使用as对导入成员重命名，以方便在当前模块内使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;reallyReallyLongModuleMemberName as shortName&#125; from &quot;my-module&quot;;</span><br></pre></td></tr></table></figure>
<p>导入多个成员时，同样可以使用别名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;reallyReallyLongModuleMemberName as shortName, anotherLongModuleName as short&#125; from &quot;my-module&quot;;</span><br></pre></td></tr></table></figure>
<p>导入一个模块，但不进行任何绑定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;my-module&quot;;</span><br></pre></td></tr></table></figure>
<p><strong>默认导入</strong></p>
<p>在模块导出时，可能会存在默认导出。同样的，在导入时可以使用import指令导出这些默认值。</p>
<p>直接导入默认值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import myDefault from &quot;my-module&quot;;</span><br></pre></td></tr></table></figure>
<p>也可以在命名空间导入和名称导入中，同时使用默认导入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import myDefault, * as myModule from &quot;my-module&quot;; // myModule 做为命名空间使用</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import myDefault, &#123;foo, bar&#125; from &quot;my-module&quot;; // 指定成员导入</span><br></pre></td></tr></table></figure>
<p>import使用示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// --file.js--</span><br><span class="line">function getJSON(url, callback) &#123;</span><br><span class="line">let xhr = new XMLHttpRequest();</span><br><span class="line">xhr.onload = function () &#123;</span><br><span class="line">callback(this.responseText)</span><br><span class="line">&#125;;</span><br><span class="line">xhr.open(&quot;GET&quot;, url, true);</span><br><span class="line">xhr.send();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function getUsefulContents(url, callback) &#123;</span><br><span class="line">getJSON(url, data =&gt; callback(JSON.parse(data)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// --main.js--</span><br><span class="line">import &#123; getUsefulContents &#125; from &quot;file&quot;;</span><br><span class="line">getUsefulContents(&quot;http://itbilu.com&quot;, data =&gt; &#123;</span><br><span class="line">doSomethingUseful(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>default关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// d.js</span><br><span class="line">export default function() &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 等效于：</span><br><span class="line">function a() &#123;&#125;;</span><br><span class="line">export &#123;a as default&#125;;</span><br></pre></td></tr></table></figure>
<p>在import的时候，可以这样用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import a from &apos;./d&apos;;</span><br><span class="line"></span><br><span class="line">// 等效于，或者说就是下面这种写法的简写，是同一个意思</span><br><span class="line">import &#123;default as a&#125; from &apos;./d&apos;;</span><br></pre></td></tr></table></figure>
<p>这个语法糖的好处就是import的时候，可以省去花括号{}。</p>
<p>简单的说，如果import的时候，你发现某个变量没有花括号括起来（没有*号），那么你在脑海中应该把它还原成有花括号的as语法。</p>
<p>所以，下面这种写法你也应该理解了吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import $,&#123;each,map&#125; from &apos;jquery&apos;;</span><br></pre></td></tr></table></figure>
<p>import后面第一个$是<code>{defalut as $}</code>的替代写法。</p>
<p><strong>as关键字</strong></p>
<p>as简单的说就是取一个别名,export中可以用，import中其实可以用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// a.js</span><br><span class="line">var a = function() &#123;&#125;;</span><br><span class="line">export &#123;a as fun&#125;;</span><br><span class="line"></span><br><span class="line">// b.js</span><br><span class="line">import &#123;fun as a&#125; from &apos;./a&apos;;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure>
<p>上面这段代码，export的时候，对外提供的接口是fun，它是a.js内部a这个函数的别名，但是在模块外面，认不到a，只能认到fun。</p>
<p>import中的as就很简单，就是你在使用模块里面的方法的时候，给这个方法取一个别名，好在当前的文件里面使用。之所以是这样，是因为有的时候不同的两个模块可能通过相同的接口，比如有一个c.js也通过了fun这个接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// c.js</span><br><span class="line">export function fun() &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>如果在b.js中同时使用a和c这两个模块，就必须想办法解决接口重名的问题，as就解决了。</p>
<p><strong>CommonJS中module.exports 与 exports的区别</strong></p>
<p><strong>Module.exports</strong></p>
<p>The module.exports object is created by the Module system. Sometimes this is not acceptable; many want their module to be an instance of some class. To do this, assign the desired export object to module.exports. Note that assigning the desired object to exports will simply rebind the local exports variable, which is probably not what you want to do.</p>
<p>译文：module.exports对象是由模块系统创建的。 有时这是难以接受的；许多人希望他们的模块成为某个类的实例。 为了实现这个，需要将期望导出的对象赋值给module.exports。 注意，将期望的对象赋值给exports会简单地重新绑定到本地exports变量上，这可能不是你想要的。</p>
<p><strong>Module.exports</strong></p>
<p>The exports variable is available within a module’s file-level scope, and is assigned the value of module.exports before the module is evaluated. It allows a shortcut, so that module.exports.f = … can be written more succinctly as exports.f = …. However, be aware that like any variable, if a new value is assigned to exports, it is no longer bound to module.exports:</p>
<p>译文：exports变量是在模块的文件级别作用域内有效的，它在模块被执行前被赋于<code>module.exports</code> 的值。它有一个快捷方式，以便 <code>module.exports.f = …</code>可以被更简洁地写成<code>exports.f = …</code>。 注意，就像任何变量，如果一个新的值被赋值给exports，它就不再绑定到<code>module.exports</code>(其实是exports.属性会自动挂载到没有命名冲突的module.exports.属性)</p>
<p>从<a href="http://nodejs.cn/api/modules.html#modules_module_exports" target="_blank" rel="noopener">Api文档</a>上面的可以看出，从require导入方式去理解，关键有两个变量(全局变量module.exports，局部变量exports)、一个返回值(module.exports)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function require(...) &#123;</span><br><span class="line">var module = &#123; exports: &#123;&#125; &#125;;</span><br><span class="line">((module, exports) =&gt; &#123;</span><br><span class="line">// 你的被引入代码 Start</span><br><span class="line">// var exports = module.exports = &#123;&#125;; (默认都有的)</span><br><span class="line">function some_func() &#123;&#125;;</span><br><span class="line">exports = some_func;</span><br><span class="line">// 此时，exports不再挂载到module.exports，</span><br><span class="line">// export将导出&#123;&#125;默认对象</span><br><span class="line">module.exports = some_func;</span><br><span class="line">// 此时，这个模块将导出some_func对象，覆盖exports上的some_func</span><br><span class="line">// 你的被引入代码 End</span><br><span class="line">&#125;)(module, module.exports);</span><br><span class="line">// 不管是exports还是module.exports，最后返回的还是module.exports</span><br><span class="line">return module.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>demo.js:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">console.log(exports); // &#123;&#125;</span><br><span class="line">console.log(module.exports); // &#123;&#125;</span><br><span class="line">console.log(exports === module.exports); // true</span><br><span class="line">console.log(exports == module.exports); // true</span><br><span class="line">console.log(module);</span><br><span class="line">/**</span><br><span class="line">Module &#123;</span><br><span class="line">id: &apos;.&apos;,</span><br><span class="line">exports: &#123;&#125;,</span><br><span class="line">parent: null,</span><br><span class="line">filename: &apos;/Users/larben/Desktop/demo.js&apos;,</span><br><span class="line">loaded: false,</span><br><span class="line">children: [],</span><br><span class="line">paths:</span><br><span class="line">[ &apos;/Users/larben/Desktop/node_modules&apos;,</span><br><span class="line">&apos;/Users/larben/node_modules&apos;,</span><br><span class="line">&apos;/Users/node_modules&apos;,</span><br><span class="line">&apos;/node_modules&apos; ] &#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>每个js文件一创建，都有一个<code>var exports = module.exports = {}</code> , 使exports和<code>module.exports</code>都指向一个空对象。</p>
<p><code>module.exports</code>和exports所指向的内存地址相同</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zxfred.github.io/2018/10/25/彻底理解JavaScript中的require、import与export/" data-id="cjozrddhd001jqzzcsrf77o5s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-RNG失利之后" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/20/RNG失利之后/" class="article-date">
  <time datetime="2018-10-20T15:14:03.000Z" itemprop="datePublished">2018-10-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/20/RNG失利之后/">RNG失利之后</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>确定RNG输掉的那一刻以至于后面的几个小时，大脑都是一片空白。麻木和呆滞，胸口憋闷，有点像当年马刺输掉第六场，看到邓肯狠狠拍地板那一下的感觉。都说是骄兵必败，是不尊重别人，是自己膨胀，我打心里面不愿意相信，想着也许是用轻松的氛围缓解压力，想着拿奥巴马轮子妈是有自己的战术安排，想着很多可能性。</p>
<p>自古以来成王败寇，赢吹输喷，年年看下来也习惯了。看Perkz赛后推特继续暗中嘲讽，只能吞下口中的屎，承认赢家有权利bb。但我们都不愿意再多等了，谁都希望LPL能拿一次世界赛的冠军，相信没人脑海中不曾构想过我们的战队可以全部挺进四强，然后会师决赛。但这一次，没倒在韩国人手里，没被SKT碾压，没有Faker大魔王统治，却输给了欧洲队甚至自己。</p>
<p>去年，在自己家门口的决赛，却是两支韩国队角逐，决赛当晚，我半夜骑车从鸟巢经过，咽下一腔的不甘与落寞。一年又一年，青春还能有几个一年。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zxfred.github.io/2018/10/20/RNG失利之后/" data-id="cjozrddgv000sqzzc08poive3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-VSCode中vue文件不能Emmet解决方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/18/VSCode中vue文件不能Emmet解决方法/" class="article-date">
  <time datetime="2018-10-18T02:39:19.000Z" itemprop="datePublished">2018-10-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/18/VSCode中vue文件不能Emmet解决方法/">VSCode中vue文件不能Emmet解决方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在 setting.json 中插入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;emmet.triggerExpansionOnTab&quot;: true,</span><br><span class="line">&quot;emmet.showAbbreviationSuggestions&quot;: true,</span><br><span class="line">&quot;emmet.showExpandedAbbreviation&quot;: &quot;always&quot;,</span><br><span class="line">&quot;emmet.includeLanguages&quot;: &#123;</span><br><span class="line">    &quot;vue-html&quot;: &quot;html&quot;,</span><br><span class="line">    &quot;vue&quot;: &quot;html&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zxfred.github.io/2018/10/18/VSCode中vue文件不能Emmet解决方法/" data-id="cjozrddgz000xqzzcapxvp1b6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-查询端口并关闭后台进程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/16/查询端口并关闭后台进程/" class="article-date">
  <time datetime="2018-10-16T05:48:04.000Z" itemprop="datePublished">2018-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/16/查询端口并关闭后台进程/">Mac OS查询端口并关闭后台进程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>找到对应的PID</span><br><span class="line">lsof -i:端口号</span><br><span class="line"><span class="meta">#</span>关闭进程</span><br><span class="line">kill -9 PID</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zxfred.github.io/2018/10/16/查询端口并关闭后台进程/" data-id="cjozrddhe001mqzzcsx8s924l" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-HTTP状态码详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/08/HTTP状态码详解/" class="article-date">
  <time datetime="2018-10-08T09:31:40.000Z" itemprop="datePublished">2018-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/08/HTTP状态码详解/">HTTP状态码详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <table>
<thead>
<tr>
<th>状态代码</th>
<th>状态信息</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>100</td>
<td>Continue</td>
<td style="text-align:left">初始的请求已经接受，客户应当继续发送请求的其余部分。（HTTP 1.1新）</td>
</tr>
<tr>
<td>101</td>
<td>Switching Protocols</td>
<td style="text-align:left">服务器将遵从客户的请求转换到另外一种协议（HTTP 1.1新）</td>
</tr>
<tr>
<td>200</td>
<td>OK</td>
<td style="text-align:left">一切正常，对GET和POST请求的应答文档跟在后面。</td>
</tr>
<tr>
<td>201</td>
<td>Created</td>
<td style="text-align:left">服务器已经创建了文档，Location头给出了它的URL。</td>
</tr>
<tr>
<td>202</td>
<td>Accepted</td>
<td style="text-align:left">已经接受请求，但处理尚未完成。</td>
</tr>
<tr>
<td>203</td>
<td>Non-Authoritative Information</td>
<td style="text-align:left">文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝（HTTP 1.1新）。</td>
</tr>
<tr>
<td>204</td>
<td>No Content</td>
<td style="text-align:left">没有新文档，浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。</td>
</tr>
<tr>
<td>205</td>
<td>Reset Content</td>
<td style="text-align:left">没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容（HTTP 1.1新）。</td>
</tr>
<tr>
<td>206</td>
<td>Partial Content</td>
<td style="text-align:left">客户发送了一个带有Range头的GET请求，服务器完成了它（HTTP 1.1新）。</td>
</tr>
<tr>
<td>300</td>
<td>Multiple Choices</td>
<td style="text-align:left">客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明。</td>
</tr>
<tr>
<td>301</td>
<td>Moved Permanently</td>
<td style="text-align:left">客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。</td>
</tr>
<tr>
<td>302</td>
<td>Found</td>
<td style="text-align:left">类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。注意，在HTTP1.0中对应的状态信息是“Moved Temporatily”。出现该状态代码时，浏览器能够自动访问新的URL，因此它是一个很有用的状态代码。注意这个状态代码有时候可以和301替换使用。例如，如果浏览器错误地请求<a href="http://host/~user（缺少了后面的斜杠），有的服务器" target="_blank" rel="noopener">http://host/~user（缺少了后面的斜杠），有的服务器</a> 返回301，有的则返回302。严格地说，我们只能假定只有当原来的请求是GET时浏览器才会自动重定向。请参见307。</td>
</tr>
<tr>
<td>303</td>
<td>See Other</td>
<td style="text-align:left">类似于301/302，不同之处在于，如果原来的请求是POST，Location头指定的重定向目标文档应该通过GET提取（HTTP 1.1新）。</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td style="text-align:left">客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告 诉客户，原来缓冲的文档还可以继续使用。</td>
</tr>
<tr>
<td>305</td>
<td>Use Proxy</td>
<td style="text-align:left">客户请求的文档应该通过Location头所指明的代理服务器提取（HTTP 1.1新）。</td>
</tr>
<tr>
<td>307</td>
<td>Temporary Redirect</td>
<td style="text-align:left">和302 （Found）相同。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是POST，即使它实际上只能在POST请求的应答是303时才能重定 向。由于这个原因，HTTP 1.1新增了307，以便更加清除地区分几个状态代码：当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只 能跟随对GET请求的重定向。（HTTP 1.1新）</td>
</tr>
<tr>
<td>400</td>
<td>Bad Request</td>
<td style="text-align:left">请求出现语法错误。</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td style="text-align:left">客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填 写合适的Authorization头后再次发出请求。</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td style="text-align:left">资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td style="text-align:left">无法找到指定位置的资源。这也是一个常用的应答。</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed</td>
<td style="text-align:left">请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）对指定的资源不适用。（HTTP 1.1新）</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable</td>
<td style="text-align:left">指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容（HTTP 1.1新）。</td>
</tr>
<tr>
<td>407</td>
<td>Proxy Authentication Required</td>
<td style="text-align:left">类似于401，表示客户必须先经过代理服务器的授权。（HTTP 1.1新）</td>
</tr>
<tr>
<td>408</td>
<td>Request Timeout</td>
<td style="text-align:left">在服务器许可的等待时间内，客户一直没有发出任何请求。客户可以在以后重复同一请求。（HTTP 1.1新）</td>
</tr>
<tr>
<td>409</td>
<td>Conflict</td>
<td style="text-align:left">通常和PUT请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。（HTTP 1.1新）</td>
</tr>
<tr>
<td>410</td>
<td>Gone</td>
<td style="text-align:left">所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和404的不同在于，返回407表示文档永久地离开了指定的位置，而 404表示由于未知的原因文档不可用。（HTTP 1.1新）</td>
</tr>
<tr>
<td>411</td>
<td>Length Required</td>
<td style="text-align:left">服务器不能处理请求，除非客户发送一个Content-Length头。（HTTP 1.1新）</td>
</tr>
<tr>
<td>412</td>
<td>Precondition Failed</td>
<td style="text-align:left">请求头中指定的一些前提条件失败（HTTP 1.1新）。</td>
</tr>
<tr>
<td>413</td>
<td>Request Entity Too Large</td>
<td style="text-align:left">目标文档的大小超过服务器当前愿意处理的大小。如果服务器认为自己能够稍后再处理该请求，则应该提供一个Retry-After头（HTTP 1.1新）。</td>
</tr>
<tr>
<td>414</td>
<td>Request URI Too Long</td>
<td style="text-align:left">URI太长（HTTP 1.1新）。</td>
</tr>
<tr>
<td>416</td>
<td>Requested Range Not Satisfiable</td>
<td style="text-align:left">服务器不能满足客户在请求中指定的Range头。（HTTP 1.1新）</td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error</td>
<td style="text-align:left">服务器遇到了意料不到的情况，不能完成客户的请求。</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented</td>
<td style="text-align:left">服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求。</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway</td>
<td style="text-align:left">服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td style="text-align:left">服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个 Retry-After头。</td>
</tr>
<tr>
<td>504</td>
<td>Gateway Timeout</td>
<td style="text-align:left">由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。（HTTP 1.1新）</td>
</tr>
<tr>
<td>505</td>
<td>HTTP Version Not Supported</td>
<td style="text-align:left">服务器不支持请求中所指明的HTTP版本。（HTTP 1.1新）</td>
</tr>
</tbody>
</table>
<p>转自：<a href="http://www.daqianduan.com/4280.html" target="_blank" rel="noopener">大前端</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zxfred.github.io/2018/10/08/HTTP状态码详解/" data-id="cjozrddgl000fqzzc1lkt7z3v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-使用npm-audit修复依赖中的安全性缺陷" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/16/使用npm-audit修复依赖中的安全性缺陷/" class="article-date">
  <time datetime="2018-08-16T07:28:20.000Z" itemprop="datePublished">2018-08-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/16/使用npm-audit修复依赖中的安全性缺陷/">使用npm audit修复依赖中的安全性缺陷</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天跑了一下一年前做的一个老项目，更新到github上之后，发现提示部分node module具有安全性缺陷，这里npm已经提供了很好的解决办法</p>
<p><code>npm audit</code></p>
<p>自动检测出需要升级的 npm 依赖</p>
<p><code>npm audit fix</code></p>
<p>自动升级 npm 依赖</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zxfred.github.io/2018/08/16/使用npm-audit修复依赖中的安全性缺陷/" data-id="cjozrddh40015qzzcbigl2t6d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-app新单品详情页踩坑总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/14/app新单品详情页踩坑总结/" class="article-date">
  <time datetime="2018-08-14T07:56:03.000Z" itemprop="datePublished">2018-08-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/14/app新单品详情页踩坑总结/">app新单品详情页踩坑总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><ul>
<li>低版本移动端对于ES6的不兼容问题，ES6出现错误不会有任何提示</li>
<li>echo 每次都要记得注释</li>
<li>VS Code 没有对 cls 模板的代码高亮支持</li>
<li>只能使用双引号，单引号会被PHP解析</li>
<li>PHP语句后面必须加分号</li>
<li>获取资源使用HTTP协议</li>
</ul>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ul>
<li>真机调试需要使用alert而不是console，有局限性</li>
<li>真机上查看不到报错信息，JS出现问题，看不到报错，只能肉眼看和alert来debug</li>
<li>两种调试方法：安卓和iOS的手机连接浏览器调试</li>
</ul>
<h2 id="联调"><a href="#联调" class="headerlink" title="联调"></a>联调</h2><ul>
<li>调用JSBridge，Android 和 iOS 返回的数据结构不一致</li>
<li>起码准备安卓和iOS两部测试机</li>
<li>客户端的改动需要重新打包，或者去平台下载最新的测试包</li>
<li>双方对于对方的操作都不可见</li>
<li>遇到问题及时沟通，因为没准不是你的bug</li>
</ul>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><ul>
<li>远程连接开发机开发，提交git麻烦</li>
<li>部署麻烦</li>
<li>前后端不分离，一起在同一个分支上改动，容易造成混乱</li>
<li>开发机资源有限，互相覆盖，代码丢失</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul>
<li>测试品较少，不能涵盖所有情况</li>
<li>安卓切换不同环境的时候回出现老的单品页</li>
<li>兼容 Android 4.4，webview的缓存问题，需要清空缓存再加载</li>
<li>真机测试，mapi必须在测试环境，不得已使用vim在开发机上做临时修改</li>
<li>频繁的环境切换，下载包、抓包、登录图形验证码，不停修改host</li>
</ul>
<h2 id="需要思考的问题"><a href="#需要思考的问题" class="headerlink" title="需要思考的问题"></a>需要思考的问题</h2><ul>
<li>HTML数据源脏数据，标签不闭合，内嵌样式，table混乱</li>
<li>JSBridge执行时机</li>
<li>不同webview内核问题</li>
<li>兼容性问题：低版本安卓、iOS</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zxfred.github.io/2018/08/14/app新单品详情页踩坑总结/" data-id="cjozrddgy000wqzzcw8djy3hu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-如何快速上手 vim" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/01/如何快速上手 vim/" class="article-date">
  <time datetime="2018-08-01T07:01:40.000Z" itemprop="datePublished">2018-08-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/01/如何快速上手 vim/">如何快速上手 vim</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>公司业务，需要 ssh 连接测试服务器修改上面的 php 文件，用 vim 打开是最方便快捷的方案，但是作为一名前端小白，仅仅只会几个简单的命令，于是找到下面的文章开始学习：</p>
<p>如何快速学会 vim 呢？<strong>默认编辑器设为 vim，删掉其他一切编辑器，明天上线。</strong></p>
<p>以下是能够在零配置下快速使用 vim 的一系列步骤，只需要多加练习，便能快速熟练使用 vim。 <strong>无他，唯手熟尔。</strong></p>
<h2 id="快速移动"><a href="#快速移动" class="headerlink" title="快速移动"></a>快速移动</h2><p><strong>快速移动是 vim 的重中之重，比一切插件都要重要</strong>。也是下编辑和修改的基础。</p>
<ul>
<li><p><strong>上(k)下(j)左(h)右(l)</strong> 移动，需要注意，禁止使用上下左右箭头 如果需要移动数行，可以在操作前加数字。如 <code>10j</code> 代表往下移动十行。 <strong>通过数字与操作结合，这是 vim 的思想。</strong></p>
</li>
<li><p>减少上一步的左右移动，效率太低，使用 <code>b, B, w, W</code> 代替 <code>b</code> 指 back a word，退回一个单词。<code>w</code> 指 forward a word，前进一个单词。 <code>B</code> 指 back a WORD，退回一个大单词。<code>w</code> 指 forward a WORD，前进一个大单词。</p>
<blockquote>
<p>其中，word 以及 WORD 的区别，以一个示例说明。 hello.world 有三个 word (‘hello’, ‘.’, ‘world’)，却只有一个 WORD。</p>
</blockquote>
</li>
<li><p>使用 <code>f, F, t, T</code> 进行更为精细的左右移动控制 <code>f</code> 指 find a character，快速移动到下一个字符的位置，<code>F</code> 指向前查找。结合 <code>b, w</code> 实现快速左右移动。 <code>t</code> 指 tail a character，快速移动到下一个字符位置的前一个字符，<code>T</code> 指向前查找。</p>
</li>
<li><p>使用 <code>0, $</code> 进行行首行尾移动</p>
</li>
<li><p>使用 <code>%</code> 快速移动到配对字符 如从左括号快速移动到右括号，左引号快速移动到右引号，在编码中最为常用！</p>
</li>
<li><p>使用 <code>&lt;Ctrl-d&gt;，&lt;Ctrl-u&gt;</code> 进行大范围上下移动 <code>&lt;Ctrl-d&gt;</code> 往下移动半页，<code>&lt;Ctrl-u&gt;</code> 往上移动半页。</p>
<blockquote>
<p>也可以使用 <code>&lt;Ctrl-f&gt;, &lt;Ctrl-b&gt;</code> 进行整页移动。</p>
</blockquote>
</li>
<li><p>使用 <code>gg, G</code> 进行首行尾行移动</p>
</li>
<li><p><code>:128</code> 表示快速定位到 128 行</p>
</li>
</ul>
<h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><p>vim 的编辑在 <code>Insert Mode</code>，以上的快速移动是在 <code>Normal Mode</code>。编辑文本需要首先进入 <code>Insert Mode</code>。</p>
<p><code>i, I, a, A, o, O</code> 进入 <code>Insert Mode</code>。</p>
<p><code>i</code> 指 insert text，在该光标前进行编辑，<code>I</code> 指在行首进行编辑。 <code>a</code> 指 append text，在该光标后进行编辑，<code>A</code> 指在行尾进行编辑。 <code>o</code> 指 append text，在该光标后一行进行编辑，<code>O</code> 指在光标前一行进行编辑。</p>
<p>个人习惯，<code>i, A, o, O</code> 用的多一些，<code>I, a</code> 基本不用。</p>
<p><code>Esc</code> 以及 <code>&lt;Ctrl-[&gt;</code> 都可以退出 <code>Insert Mode</code>。</p>
<p>个人习惯使用 <code>&lt;Ctrl-[&gt;</code>，一来 <code>Esc</code> 过远，二来在一些编辑器中 <code>Esc</code> 容易与其它热键冲突。</p>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>删除也可以在 <code>Insert Mode</code> 使用 <code>delete</code> 键进行手动删除，不过效率太低，建议一般在 <code>Normal Mode</code> 进行删除，刚进入 vim 的状态便是 <code>Normal Mode</code>。</p>
<ul>
<li><p>使用 <code>x(dl)</code> 删除特定字符 可以结合 <code>x</code> 以及上述所讲的快速移动，删掉光标下的特定字符</p>
<p>在括号里标注 <code>l</code>，意指 <code>x</code> 为 <code>dl</code> 的简写。</p>
<p><strong>d 指 delete，表示删除，是所有修改操作的基础。dl 由 d 和 l 两个操作组成，代表删掉光标右侧的字符，同理，dh 代表删掉光标左侧的字符，这是所有删除的基本形式，也是 vim 的核心思想。</strong></p>
</li>
<li><p>使用 <code>daw</code> 删除特定单词</p>
<p><code>daw</code> 指 <code>delete a word</code>，表示删除特定单词。同样也可以使用 <code>db, dw</code> 来删除单词。</p>
</li>
<li><p>使用 <code>dt, df</code> 加特定字符，删掉字符前的文本</p>
</li>
<li><p>使用 <code>di(, da(</code> 删除特定符号内的文本，如删除括号，引号中的文本</p>
<p><code>di(</code> 指 <code>delete in (</code>，不会删掉括号。<code>da(</code> 指 <code>delete a (</code>，会连同括号一同删掉。同理还有 <code>di&#39;</code>，<code>di&quot;</code> 等，在编码中最为常用！</p>
</li>
<li><p>使用 <code>D (d$)</code> 删除掉该字符以后的所有文本</p>
</li>
<li><p>使用 <code>dd</code> 删掉整行</p>
</li>
<li><p><strong>把以上操作的所有 d 替换为 c，表示删除后进入编辑模式</strong></p>
<p><code>c</code> 指 <code>change</code>，表示删除，如 <code>d</code> 一样，是 vim 的基本动词</p>
</li>
<li><p>使用 <code>r</code> 加特定字符，表示使用特定字符代替原有字符</p>
</li>
</ul>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><ul>
<li><p>使用 <code>:Ex (Explore)</code> 浏览目录</p>
<p>定位到文件所在行，回车进入指定文件</p>
</li>
<li><p>使用 <code>ls</code> 列出缓冲列表</p>
<p>缓冲列表中保存最近使用文件，行头有标号</p>
</li>
<li><p>使用 <code>bn</code> 进入最近使用文件</p>
<p><code>bn</code> 指 <code>buffer next</code>，进入缓冲列表的下个缓冲，即最近一次使用文件</p>
</li>
<li><p>使用 <code>b [N]</code> 进入缓冲列表中标号为 N 的文件</p>
<p><code>b 10</code> 指 <code>buffer 10</code>，进入缓冲列表，即最近一次使用文件</p>
</li>
<li><p>使用 <code>sbn, vbn</code> 在新窗口打开最近使用文件</p>
<p><code>s</code> 指 <code>split</code>，水平方向。 <code>v</code> 指 <code>vertical</code>，垂直方向。</p>
</li>
</ul>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>基本操作指查找，替换，撤销，重做，复制，粘贴，保存等</p>
<ul>
<li><p><code>/{pattern}</code> 查找 <code>/</code> 后加需要查找的词或者正则表达式进行查询，<code>n</code> 向下查询，<code>N</code> 向上查询。</p>
</li>
<li><p><code>:s/aa/bb/g</code> 替换 <code>s</code> 指 <code>substitute</code> 的缩写，替换，<code>g</code> 代表全局替换。</p>
</li>
<li><p><code>u</code> 撤销 <code>u</code> 指 <code>undo</code> 的缩写，撤销。可与数字结合进行多次撤销。</p>
</li>
<li><p><code>&lt;Ctrl-r&gt;</code> 重做</p>
</li>
<li><p><code>yy</code> 复制整行 <code>y</code> 指 <code>yank</code>，复制。使 <code>y</code> 与快速移动结合起来，可以使用多种情况的复制，如复制括号中内容，复制引号中内容。</p>
<p>复制时，会把当前内容置入寄存器，使用 <code>:reg</code> 查看寄存器列表。</p>
</li>
<li><p><code>p</code> 粘贴 <code>p</code> 指 <code>paste</code>，粘贴。</p>
</li>
<li><p><code>&quot;*y</code> 复制内容至系统剪切板</p>
<p><code>:reg</code> 会列出寄存器列表，<code>&quot;*</code> 寄存器代表系统剪切板()，所以以上就是把内容放到系统剪切板。</p>
<p>如果寄存器列表中没有该寄存器，则 vim 不支持系统剪切板，也可以使用命令 <code>vim --version | grep clipboard</code>。</p>
</li>
<li><p><code>&quot;*p</code> 粘贴系统剪切板中内容</p>
</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>关于配置，推荐一下 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Famix%2Fvimrc" target="_blank" rel="noopener">amix/vimrc</a> ，在 github 上超过一万四千颗星。</p>
<p>另外，再推荐下作者的配置 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fshfshanyue%2Fvim-config" target="_blank" rel="noopener">shfshanyue/vim-config</a>，其中有一些插件，如 <code>emmet</code> 和 <code>typescript</code>非常适合前端开发。</p>
<hr>
<p>转载自：<a href="https://juejin.im/post/5b602e1951882569fd288446" target="_blank" rel="noopener">https://juejin.im/post/5b602e1951882569fd288446</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zxfred.github.io/2018/08/01/如何快速上手 vim/" data-id="cjozrddh7001aqzzcxgi19eau" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-20个强大的正则表达式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/31/20个强大的正则表达式/" class="article-date">
  <time datetime="2018-07-31T07:23:14.000Z" itemprop="datePublished">2018-07-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/31/20个强大的正则表达式/">20个强大的正则表达式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>正则表达式，一个十分古老而又强大的文本处理工具，仅仅用一段非常简短的表达式语句，便能够快速实现一个非常复杂的业务逻辑。熟练地掌握正则表达式的话，能够使你的开发效率得到极大的提升。</p>
<p>正则表达式经常被用于字段或任意字符串的校验，如下面这段校验基本日期格式的JavaScript代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var reg = /^(\\d&#123;1,4&#125;)(-|\\/)(\\d&#123;1,2&#125;)\\2(\\d&#123;1,2&#125;)$/; </span><br><span class="line">var r = fieldValue.match(reg);             </span><br><span class="line">if(r==null)alert(&apos;Date format error!&apos;);</span><br></pre></td></tr></table></figure>
<p>下面是<strong>技匠</strong>整理的，在前端开发中经常使用到的<strong>20</strong>个正则表达式。</p>
<hr>
<h4 id="1-校验密码强度"><a href="#1-校验密码强度" class="headerlink" title="1 . 校验密码强度"></a><strong>1 . 校验密码强度</strong></h4><p>密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$</span><br></pre></td></tr></table></figure>
<h4 id="2-校验中文"><a href="#2-校验中文" class="headerlink" title="2. 校验中文"></a><strong>2. 校验中文</strong></h4><p>字符串仅能是中文。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[\\u4e00-\\u9fa5]&#123;0,&#125;$</span><br></pre></td></tr></table></figure>
<h4 id="3-由数字、26个英文字母或下划线组成的字符串"><a href="#3-由数字、26个英文字母或下划线组成的字符串" class="headerlink" title="3. 由数字、26个英文字母或下划线组成的字符串"></a><strong>3. 由数字、26个英文字母或下划线组成的字符串</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\\w+$</span><br></pre></td></tr></table></figure>
<h4 id="4-校验E-Mail-地址"><a href="#4-校验E-Mail-地址" class="headerlink" title="4. 校验E-Mail 地址"></a><strong>4. 校验E-Mail 地址</strong></h4><p>同密码一样，下面是E-mail地址合规性的正则检查语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[\\w!#$%&amp;&apos;*+/=?^_`&#123;|&#125;~-]+(?:\\.[\\w!#$%&amp;&apos;*+/=?^_`&#123;|&#125;~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])?</span><br></pre></td></tr></table></figure>
<h4 id="5-校验身份证号码"><a href="#5-校验身份证号码" class="headerlink" title="5. 校验身份证号码"></a><strong>5. 校验身份证号码</strong></h4><p>下面是身份证号码的正则校验。15 或 18位。</p>
<p>15位：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[1-9]\\d&#123;7&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;$</span><br></pre></td></tr></table></figure>
<p>18位：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[1-9]\\d&#123;5&#125;[1-9]\\d&#123;3&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;([0-9]|X)$</span><br></pre></td></tr></table></figure>
<h4 id="6-校验日期"><a href="#6-校验日期" class="headerlink" title="6. 校验日期"></a><strong>6. 校验日期</strong></h4><p>“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(?:(?!0000)[0-9]&#123;4&#125;-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$</span><br></pre></td></tr></table></figure>
<h4 id="7-校验金额"><a href="#7-校验金额" class="headerlink" title="7. 校验金额"></a><strong>7. 校验金额</strong></h4><p>金额校验，精确到2位小数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[0-9]+(.[0-9]&#123;2&#125;)?$</span><br></pre></td></tr></table></figure>
<h4 id="8-校验手机号"><a href="#8-校验手机号" class="headerlink" title="8. 校验手机号"></a><strong>8. 校验手机号</strong></h4><p>下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$</span><br></pre></td></tr></table></figure>
<h4 id="9-判断IE的版本"><a href="#9-判断IE的版本" class="headerlink" title="9. 判断IE的版本"></a><strong>9. 判断IE的版本</strong></h4><p>IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\/[5-9]\\.0).*$</span><br></pre></td></tr></table></figure>
<h4 id="10-校验IP-v4地址"><a href="#10-校验IP-v4地址" class="headerlink" title="10. 校验IP-v4地址"></a><strong>10. 校验IP-v4地址</strong></h4><p>IP4 正则语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b</span><br></pre></td></tr></table></figure>
<h4 id="11-校验IP-v6地址"><a href="#11-校验IP-v6地址" class="headerlink" title="11. 校验IP-v6地址"></a><strong>11. 校验IP-v6地址</strong></h4><p>IP6 正则语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(([0-9a-fA-F]&#123;1,4&#125;:)&#123;7,7&#125;[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,7&#125;:|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,6&#125;:[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,5&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,2&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,3&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,3&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,2&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,5&#125;|[0-9a-fA-F]&#123;1,4&#125;:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,6&#125;)|:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,7&#125;|:)|fe80:(:[0-9a-fA-F]&#123;0,4&#125;)&#123;0,4&#125;%[0-9a-zA-Z]&#123;1,&#125;|::(ffff(:0&#123;1,4&#125;)&#123;0,1&#125;:)&#123;0,1&#125;((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;:((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9]))</span><br></pre></td></tr></table></figure>
<h4 id="12-检查URL的前缀"><a href="#12-检查URL的前缀" class="headerlink" title="12. 检查URL的前缀"></a><strong>12. 检查URL的前缀</strong></h4><p>应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (!s.match(/^[a-zA-Z]+:\\/\\//))</span><br><span class="line">&#123;</span><br><span class="line">    s = &apos;http://&apos; + s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="13-提取URL链接"><a href="#13-提取URL链接" class="headerlink" title="13. 提取URL链接"></a><strong>13. 提取URL链接</strong></h4><p>下面的这个表达式可以筛选出一段文本中的URL。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(f|ht)&#123;1&#125;(tp|tps):\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- ./?%&amp;=]*)?</span><br></pre></td></tr></table></figure>
<h4 id="14-文件路径及扩展名校验"><a href="#14-文件路径及扩展名校验" class="headerlink" title="14. 文件路径及扩展名校验"></a><strong>14. 文件路径及扩展名校验</strong></h4><p>验证windows下文件路径和扩展名（下面的例子中为.txt文件）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?&quot;&lt;&gt;|]+\\.txt(l)?$</span><br></pre></td></tr></table></figure>
<h4 id="15-提取Color-Hex-Codes"><a href="#15-提取Color-Hex-Codes" class="headerlink" title="15. 提取Color Hex  Codes"></a><strong>15. 提取Color Hex  Codes</strong></h4><p>有时需要抽取网页中的颜色代码，可以使用下面的表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^#([A-Fa-f0-9]&#123;6&#125;|[A-Fa-f0-9]&#123;3&#125;)$</span><br></pre></td></tr></table></figure>
<h4 id="16-提取网页图片"><a href="#16-提取网页图片" class="headerlink" title="16. 提取网页图片"></a><strong>16. 提取网页图片</strong></h4><p>假若你想提取网页中所有图片信息，可以利用下面的表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\&lt; *[img][^\\\\&gt;]*[src] *= *[\\&quot;\\&apos;]&#123;0,1&#125;([^\\&quot;\\&apos;\\ &gt;]*)</span><br></pre></td></tr></table></figure>
<h4 id="17-提取页面超链接"><a href="#17-提取页面超链接" class="headerlink" title="17. 提取页面超链接"></a><strong>17. 提取页面超链接</strong></h4><p>提取html中的超链接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&lt;a\\s*(?!.*\\brel=)[^&gt;]*)(href=&quot;https?:\\/\\/)((?!(?:(?:www\\.)?&apos;.implode(&apos;|(?:www\\.)?&apos;, $follow_list).&apos;))[^&quot;]+)&quot;((?!.*\\brel=)[^&gt;]*)(?:[^&gt;]*)&gt;</span><br></pre></td></tr></table></figure>
<h4 id="18-查找CSS属性"><a href="#18-查找CSS属性" class="headerlink" title="18. 查找CSS属性"></a><strong>18. 查找CSS属性</strong></h4><p>通过下面的表达式，可以搜索到相匹配的CSS属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\\s*[a-zA-Z\\-]+\\s*[:]&#123;1&#125;\\s[a-zA-Z0-9\\s.#]+[;]&#123;1&#125;</span><br></pre></td></tr></table></figure>
<h4 id="19-抽取注释"><a href="#19-抽取注释" class="headerlink" title="19. 抽取注释"></a><strong>19. 抽取注释</strong></h4><p>如果你需要移除HMTL中的注释，可以使用如下的表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--(.*?)--&gt;</span><br></pre></td></tr></table></figure>
<h4 id="20-匹配HTML标签"><a href="#20-匹配HTML标签" class="headerlink" title="20. 匹配HTML标签"></a><strong>20. 匹配HTML标签</strong></h4><p>通过下面的表达式可以匹配出HTML中的标签属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;\\/?\\w+((\\s+\\w+(\\s*=\\s*(?:&quot;.*?&quot;|&apos;.*?&apos;|[\\^&apos;&quot;&gt;\\s]+))?)+\\s*|\\s*)\\/?&gt;</span><br></pre></td></tr></table></figure>
<p>转载自简书：<a href="https://www.jianshu.com/p/e7bb97218946" target="_blank" rel="noopener">https://www.jianshu.com/p/e7bb97218946</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zxfred.github.io/2018/07/31/20个强大的正则表达式/" data-id="cjozrddg00000qzzc5oj8xg19" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序-Vue/">微信小程序 Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 13.33px;">CSS</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/微信小程序/" style="font-size: 10px;">微信小程序</a> <a href="/tags/微信小程序-Vue/" style="font-size: 10px;">微信小程序 Vue</a> <a href="/tags/数据结构/" style="font-size: 16.67px;">数据结构</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/27/ES6使用模板字符串进行模板编译/">ES6使用模板字符串进行模板编译</a>
          </li>
        
          <li>
            <a href="/2018/11/23/ES6解构赋值的用途/">ES6解构赋值的用途</a>
          </li>
        
          <li>
            <a href="/2018/11/20/Promise中能catch到什么/">Promise中能catch到什么</a>
          </li>
        
          <li>
            <a href="/2018/11/19/JavaScript中的执行环境/">JavaScript中的执行环境</a>
          </li>
        
          <li>
            <a href="/2018/11/19/JavaScript拷贝数组/">JavaScript拷贝数组</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Fred Zhang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>